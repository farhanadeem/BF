
var tipuesearch = {"pages": [

     {"title": "Welcome!", "text": "The Bugs Framework (BF)* organizes software weaknesses (bugs) into distinct classes, such as Buffer Overflow (BOF), Injection (INJ), and Control of Interaction Frequency (CIF). Each BF class has an accurate and precise definition and comprises: Level (high or low) that identifies the fault as language-related or semantic. Attributes that identify the software fault. Causes that bring about the fault. Consequences the fault could lead to. Sites in code where the fault might occur. BF provides a superior, unified approach that allows us to: Precisely and unambiguously express software bugs or vulnerabilities. Estimate risk and determine best mitigation strategies based on known consequences of different kinds of faults. Explain clearly applicability and utility of different software quality or assurance techniques or approaches. More formally reason about assurance techniques or mitigation approaches that may work for a fault with with certain attributes. With BF practitioners and researchers can more accurately, precisely and clearly: Describe problems in software and discuss the classes of bugs that tools report. Explain what vulnerabilities the proposed techniques prevent. Those concerned with software quality, the reliability of programs and digital systems, or cybersecurity will be able to make more rapid progress by more clearly labeling the results of errors in software. Those responsible for designing, operating and maintaining computer complexes can communicate with more exactness about threats, attacks, patches and exposures. As BF covers more classes: Existing taxonomies, like CWE, can start explaining their current entries with concise forms of BF descriptions. Bug trackers (many already use CWEs) also can be enhanced to report in terms of BF descriptions. Approach To achieve higher levels of security, reliability and availability of digital systems, we need to answer questions such as: Does this software have bugs of these critical classes? Do two software assurance tools find the same set of bugs or different, complimentary sets? Can we guarantee that a new technique discovers all problems of this type? To be able to answer these questions, we need a vastly improved way to describe classes of vulnerabilities and chains of failures. For that we are developing the Bugs Framework (BF) by factoring and restructuring of information contained in Common Weakness Enumeration (CWE), Software Fault Patterns (SFP), Semantic Templates (ST) and numerous other sources on software vulnerabilities and attacks (see the Enlightenment link). The goal is to categorize unambiguously the types of weaknesses, allowing similarities and differences to be easily explored and examined. The BF organizes software weaknesses (bugs) into distinct classes, such as Buffer Overflow (BOF), Injection (INJ), and Control of Interaction Frequency (CIF). It is an hierarchy of abstract & concrete classes of bugs with: Precise Definitions. Level: either low (language-related) or high (semantic). A low level class only occurs in some languages, like BOF, or relates to numbers, like integer overflow in FRS. A high level class, like CRY, INJ, or CIF, deals with domain concepts like passwords and accounts and commands; it does not depend on the number of bits in an int. Attributes that identify or distinguish the software fault. Each attribute is an enumeration of possible values. For instance, some BOF attributes are &quotAccess: Read or Write&quot, &quotBoundary: Above or Below&quot, and &quotLocation: Heap or Stack&quot.Directed graph(s) of Causes that bring about faults, which include implementation mistakes, conditions, preceding weaknesses and circumstances that bring about the fault. Some causes are nested hierarchically. For instance, &quotData Exceeds Array&quot in BOF is either &quotArray Too Small&quot or &quotToo Much Data.&quot&quot Directed graph(s) of Consequences faults could lead to. Consequences also may be hierarchical. Causes-Attributes-Consequences Mappings. Possible Sites in code where faults might occur under circumstances indicated by the causes. That is, locations that must be reviewed for possible faults. Note that the attributes describe an event, not the site in code that gives rise to the event. *The BF is being created by factoring and restructuring of information contained in CWE, SFP, NSA CAS, SOAR, SEI-CERT, and others, and thus benefits from the community's experience with their use. Instead of trying to match weakness classes that tools find to CWEs, usually far over- or under-generalizing, the BF can describe tool classes much more accurately, precisely and succinctly. We believe that as CWEs migrate to using this kind of taxonomy, they will be easier to comprehend and avoid.", "tags": "", "url": "https://samate.nist.gov/BF/index.html"},

     {"title": "News and Events", "text": "September 26, 2017: Bojanova, I., Black, P. E., Yesha, Y., Cryptography Classes in Bugs Framework (BF): Encryption Bugs (ENC), Verification Bugs (VRF), and Key Management Bugs (KMN). IEEE Software Technology Conference (STC 2017), NIST, Gaithersburg, MD, USA.September 25, 2017:	Bojanova, I., Black, P. E., Yesha, Y., Wu, Yan, Evans, Z., Poster: The Bugs Framework (BF) – First Classes: Buffer Overflow (BOF), Injection (INJ), Control of Interaction Frequency (CIF), STC 2017, NIST, Gaithersburg, MD, USA.September 25, 2017:	Bojanova, I., Black, P. E., Yesha, Y., Poster: Cryptography Classes in Bugs Framework (BF): Encryption Bugs (ENC), Verification Bugs (VRF), and Key Management Bugs (KMN)&quot, STC 2017, NIST, Gaithersburg, MD, USA.July 25, 2017:	Meeting with John Kelsey and Andrew Regenscheid to discuss our Crypto Model and the CRY, _ENC, _VRF, and _KMN classes.May 8, 2017: Bojanova, I., Black, P. E., Poster: Rigorous Descriptions of Two New BF Classes: Cryptography (CRY) and Faulty Result (FRS), HCSS 2017, Annapolis, MD, USA.April 19, 2017: Meeting with John Kelsey and Andrew Regenscheid to discuss our Crypto Model and the CRY, _ENC, _VRF, and _KMN classes.April 4, 2017: Bojanova, I., Black, P. E., Yesha, Y., Wu, Y., Tutorial: The Bugs Framework (BF) &quotHands-On&quot, HotSoS 2017, Hanover, MD, USA. January, 12, 2017: Bojanova, I., Black, P. E., Wu, Y., Evans, Z. Discussion on BF classes. Irena committed to defining at least 5 new BF classes in FY 2017 (e.g. CRY, ENC, VRF, KMN, ATN, FRS, RND, AUT, ...) We talked about CRY. When is something an attribute, when is it a cause, and when is it extra (&quotmeta&quot) information? Many CRY-related CVEs mention the protocol involved. Does that matter to BF? No, because it does not change our understanding of whether something was a bug or where the bug is. As Irena kept reminding us, what piece of code is bad? As Paul kept reminding us, when did the program state go bad and what is bad about it? The protocol, then, is extra information, like line number, file name, or function name for BOF. It is useful for coders, in that it tells *where* the bug is, but doesn't really enlighten us as to what went wrong. What is the relation between ENC, Key management, Verification, etc. and CRY? We think it is best represented as an attribute, call it Step or Process, which is an enumeration, specifying at which step or phase of the crypto process the fault occurs. Those are possible values of Step/Process. We decided that &quotspoof messages&quot and &quotbypass authentication (then gain privileges)&quot are consequences of CRY (not attributes). Note: &quotdata at rest&quot (as opposed to data being transmitted) is an important concern in crypto these days. Our definition of CRY includes (or, is meant to include) data at rest in the term &quothandled&quot, in addition to transferred. November 2, 2016:	BF team (Bojanova, I.) & DSU INSuRE team (Bogdanovic, J., Lutgen, J., VanGerpen, C.) discussion the midterm presentation for developing Cryptography related BF class(es). November 2, 2016: Bojanova, I., Black, P. E., Yesha, Y., Wu, Y. , The Bugs Framework (BF): A Structured Approach to Express Bugs, Security Research Review (SSR), NIST. October 26, 2016:Bojanova, I., Black, P. E., Wu, Y., Discussion on BF classes. 1. Decided on a new FLO (control Flow) class under &quotBF Classes related to Functionality&quot. 2. Placed CIF under &quotBF Classes related to Access&quot. 3. Placed INJ under &quotBF Classes related to Functionality&quot. 4. Decided on MEM, STO, NET classes under &quotBF Classes related to Data&quot. Placed BOF under MEM. 5. Started discussion on questioning if IEX is a class: Is this a (fault) class? Or is it a consequence (with attributes)? It seems that IEX might be an attribute or factor in all the Data classes (MEM, STO, and NET). But it is also a high level concept closely related to Access. October 5, 2016: BF team (Bojanova, I., Black, P. E., Yesha, Y., Evans, Z.) & DSU INSuRE team (Bogdanovic, J., Lutgen, J., Alshboul, Y.) discussion and planning for developing Crytography related BF classes. Decided to developa plan in three steps: (1) Research on identifying model(s) related to cryptography; (2) Decide on BF class(es) related to cryptography; (3) Determine causes, attributes, and consequences for these classes -- plus, in parallel work on defining some cryptography related CVEs. September 6, 2016: Black, P. E., Bojanova, I., Kelsey, J., Peralta, R., Discussion on the philosophy of cryptography. August 31, 2016: Bojanova, I., Black, P. E., Yesha, Y., Discussion on the ENC(--> CRY), RND, and CON classes; and conceptually on memory, storage, and networking. 1. The new class should be cryptography, not encryption (ENC). The latter is only one part of the former. Cryptography includes key exchange, protocols, identifying the other party, etc. Possible designations are CRY and CYP. Note: How is IEX related to this class? 2. Randomization could be designated RND. 3. Concurrency (CON) should be a new separate class. It covers issues like deadlock, starvation (unfair scheduling), races, locks, and synchronization. 4. There should be another new class for Exceptions (EXP or EXC or ECP). This covers exception handling, e.g. throw, try, catch. It is not meant for the exceptions themselves, like divide by zero throwing an exception. 5. There are other control flow problems that should be somewhere: Branching, Looping, Switch without default, Infinite loop. 6. We found the Linux kernel map to be a useful source to ask if we covered everything. In general, we felt that most of the details in the map were too low level for what we do. Why? Few vulnerabilities are tied to, say, a device driver or a scheduling algorithm. We think that's because most of the kernel presents an abstract machine to the programmer. That abstract machine is the same regardless of the hardware. That said, we saw a conceptual difference between Memory and Storage. Storage is typically intricately structured, that is, with a file system. Access is largely by means of the file system with all its names, permissions, links, etc. Memory is usually just a giant array, maybe with allocation and freeing. The second difference is that storage is generally persistent. One thinks of files as lasting far longer than processes. Because of these differences, the weakness classes will likely not overlap and be very different. We also believe that Network is significantly different from either of those. August 23, 2016: Bojanova, I., Black, P. E., Yesha, Y., Discussion on a New BF Class (ENC), the FRS class, and application examples on recent BOF CVEs. 1. Encryption (ENC) should be a new class. True, in one sense it is just one more application, like hash tables, but (a) it is often critical to security, (b) there are adversaries, and (c) tiny details may enable failures. Therefore, it deserves a separate class. Many &quotencryption&quot CWEs should really be in other classes. For instance, CWE-347 Improper Verification of Cryptographic Signature and CWE-640 Weak Password Recovery Mechanism for Forgotten Password should be in other BF classes. Random numbers, randomization, pseudorandom number generation, etc. should be a class, for reason like ENC. However, random numbers are also critical to simulations, statistical analysis, Monte Carlo algorithms, and randomized algorithms (like skip lists and load balancing). Therefore, we are keeping it separate from ENC. 2. We tried to make it clear(er) that &quotdata type&quot is kind of a sub- or meta-attribute for FRS. That is, operator=divide and o-fault=zero doesn't matter if the dividend (number being divided) is int, float, double, or complex. However, o-fault=&quotmismatched data types&quot should/could be characterized as int and float, for example. Uninitialized variable is NOT FRS. There is no operation going on. Or rather, ALL operators (except maybe assignment) would have the same o-fault of &quotuse of uninitialized value&quot, which does not seem very informative. 3. We talked about why CVE-2015-2282 says &quotstack-based buffer overflow.&quot We agree that it is BOF. However, it is probably loc=heap. (We're not sure because the allocation of the memory is in some another file, and we didn't feel like taking the time to chase it down.) We posit that &quotstack-based&quot was added because the code had a variable named &quotstackp&quot. (By the way, we looked it up: the CVE folk write the CVE description, based on information they collect.) Two new BOF examples will be added (CVE-2015-2282, CVE-2015-2278), as well as the following arrow will be added to the BOF graph: Input Not Checked Properly can directly cause Wrong Index/Pointer Out of range. August 16, 2016: Bojanova, I., Black, P. E., Yesha, Y., Discussion on New BF Classes (ATN, AUT, FRS). We are pretty comfortable with Authentication (ATN) (Make sure entity is who they claim to be), Authorization (AUT) (Make sure entity is allowed to perform the operation - often conflated with access control), and Faulty Result (FRS). The last is called Risky Value in one source (SFP), Number Handling in two others (SOAR, CAS), and covers three classes in CERT C: Expression, Integer, and Floating Point. This class includes divide by zero, integer overflow, improper parameters in calls, problems with casts, and others. August 3, 2016: Our initial work on BF was presented at the QRS 2016 conference by T.H. Tse (University of Hong Kong) in his Keynote Speech. Citing Einstein's &quotSo many people today-and even professional scientists-seem to me like somebody who has seen thousands of trees but has never seen a forest&quot, he made an analogy to how with our BF idea we plan to &quotlook at all the faults and not only at separate ones&quot. August 1, 2016:	Bojanova, I., Black, P. E., Yesha, Y., Wu, Y. The Bugs Framework (BF): A Structured Approach to Express Bugs. QRS 2016, Vienna, Austria. July 13, 2016: Bojanova, I., Black, P. E., Yesha, Y., Wu, Y. The Bugs Framework (BF). Poster. S5 2016, AFRL, Dayton, OH. June 24, 2016: NIST and IDA discussion on the Bugs Framework (BF). June 28, 2016:SSD and CSD discussion on the Bugs Framework (BF) and the Next Generation CWEs. May 10, 2016: Black, P. E., Bojanova, I., Yesha, Y., Wu, Y., Toward a Precise and Accurate Basis of Measurements. Poster. HCSS 2016, Annapolis, MD. April 17, 2016: Bojanova, I., Black, P. E., Yesha, Y., Wu, Y., Toward a Structured, Integrated Framework (e.g. Periodic Table) to Express Software Bugs. Poster. CyberSec 2016, Coeur d'Alene, ID. Oct. 27, 2016:	Black, P. E., Bojanova, I., Precise and Rational Bug Descriptions. Poster. ITL Science Day, NIST, MD. Jan. 5, 2016: Black, P. E., Software Assurance Efforts in the SSD, Japanese IPA Delegation, NIST, MD. Nov. 18, 2015: Black, P. E., Toward a &quotPeriodic Table&quot of Bugs, or, How Can I Really Tell What's Wrong With My Code?, Lab Tour. OWASP Northern Virginia (NoVa) Chapter. VA. Sept. 2, 2015: Black, P. E., Bojanova, I., Yesha, Y., Wu, Y., Toward a &quotPeriodic Table&quot of Bugs, or, How Can I Really Tell What's Wrong With My Code?, OWASP Washington D.C. Chapter. Washington DC. Aug. 26, 2015: Black, P. E., Bojanova, I., Yesha, Y., Wu, Y., Toward a &quotPeriodic Table&quot of Bugs, or, How Can I Really Tell What's Wrong With My Code?, Lab Tour, NIST, MD. May 7, 2015: Black, P. E., Bojanova, I., Yesha, Y., Wu, Y., Towards a &quotPeriodic Table&quot of Bugs, HCSS 2015, Annapolis, MD. April 15, 2015:	Black, P. E., Bojanova, I., Yesha, Y., Wu, Y., A More Orthogonal Encyclopedia of Software Weaknesses than CWE, Software Security Assurance Exploratory Group Meeting, Washington D.C. June 9, 2015: Black, P. E., Software Assurance, National Research Council (NRC) Assessment Panel, NIST, MD. June 11, 2015:	Black, P. E., On a CWE Effectiveness Test Suite, Center for Assured Software (CAS), NIST, MD. Dec. 2, 2015:Black, P. E., Test Methods and Their Standardization for Identified & Unidentified Vulnerability Tests, Japanese National Institute of Advanced Industrial Science and Technology (AIST), NIST, MD. Feb. 27, 2015: Bojanova, I., Wu, Y. Formalizing Software Bugs. Bowling Green State University (BGSU), OH. April 2, 2014:	Wu, Y., Bojanova, I., Yesha, Y. Reconstruction of Common Weakness Enumeration. 2014 IEEE Software Technology Conference (STC 2014). Long Beach, CA. Dec. 10, 2014: Bojanova, I. Formalizing Software Bugs. Japanese IPA Delegation, NIST, MD.", "tags": "", "url": "https://samate.nist.gov/BF/Home/News%20and%20Events.html"},

     {"title": "Contact Info", "text": "Irena Bojanova Software Systems Division (SSD) Information Technology Laboratory (ITL) National Institute of Standards and Technology (NIST) 100 Bureau Dr, Stop 8930 Chemistry 222, Room A307 Gaithersburg, MD 20899 phone: 301 975 2794 email: irena.bojanova@nist.gov", "tags": "", "url": "https://samate.nist.gov/BF/Home/Contact%20Info.html"},

     {"title": "Background", "text": "The medical profession has an extensive, elaborate vocabulary to precisely name muscles, bones, organs, conditions and diseases. When a doctor says that a comatose patient has a left temporal lobe epidural hematoma, the intention is to enlighten, not to obfuscate. In the software profession, we have many efforts that have helped us develop terms to discuss software, faults, failures, attacks and vulnerabilities, such as the Common Weakness Enumeration (CWE) and Landwehr et. al. Taxonomy of Computer Program Security Flaws, but much work remains. We want to more accurately and precisely define software bugs or vulnerabilities. Consider that including &quotcanary&quot values around arrays detects some buffer overflows while using address layout randomization mitigates other buffer overflows. A precise, orthogonal nomenclature can state exactly which classes of buffer overflows each approach handles. We can also clearly state the classes of bugs that a tool can find and more easily determine if two tools generally find the same set of bugs or if they find different, complimentary sets. Through centuries of experimentation and development of scientific principles, we now have the Periodic Table of Elements. Just as the structure of the periodic table reflects the underlying atomic structure, we are developing a taxonomy dictated by the &quotnatural&quot organization of software bugs, while using as stepping stones known bugs enumerations, compendia and collections. For this and other analogies on what we are embarking on, we recall below some well-know organizational structures in science. Science has developed many different organizational structures. For example, the Periodic Table of Elements, the recently rearranged Tree of Life, the Geographic Coordinate System, and the Dewey Decimal Classification System. Mendeleev's Periodic Table - However obvious the Mendeleev's Periodic Table seems today, it required extensive thought and investigation: Greeks used element and atom to name differences between materials and smallest parts of matter. In 330 BC, Aristotle proposed that everything is a mixture of &quotroot elements&quot: Earth, Fire, Air, Water. Lavoisier created a list of 33 elements - e.g. oxygen, nitrogen, hydrogen, phosphorus, mercury, zinc, sulfur, light, and caloric, and distinguished metals from non-metals. Dalton realized &quotatoms of same element are identical in all respects, particularly weight.&quot In 1800s, several tables of elements were developed: De Chancourtois first noticed periodicity of elements. When ordered by their atomic weights, similar elements occur at regular intervals. Mendeleev's Periodic Table in 1869 and his forecast of properties of missing elements reflected the century of growth in knowledge that reflects atomic structure: Columns correspond to the number of electrons in the outer shell and the fundamental chemical properties. Rows correspond to the number of electron shells. Tree of Life - Discoveries of more than 1,000 new types of bacteria and Archaea over the past 15 years have dramatically rejiggered the Tree of Life to account for these microscopic life forms. The new Tree of Life divides life into three domains: Bacteria, Archaea and Eukaryotes. It clearly shows that &quotlife we see around us - plants, animals, humans and other so-called eukaryotes - represent a tiny percentage of the world's biodiversity.&quot Geographic Coordinate System - The Geographic Coordinate System allows to specify any location on the Earth using Latitude, Longitude and Elevation. Longitude lines are perpendicular and latitude lines are parallel to the equator. Dewey Decimal Classification System - The Dewey Decimal Classification System allows new books and whole new subjects to be placed in reasonable locations in a library, for easy retrieval based on subject. References [1] The MITRE Corporation. Common Weakness Enumeration (CWE). [2] C. E. Landwehr, A. R. Bull, J. P. McDermott, and W. S. Choi. A taxonomy of computer program security flaws, and examples. ACM Computing Surveys. vol. 26. no. 3. pp. 211-254. September 1994.", "tags": "", "url": "https://samate.nist.gov/BF/Background/index.html"},

     {"title": "Classes - Buffer Overflow", "text": "Definition: The software accesses through an array a memory location that is outside the boundaries of that array. Often referred to as a &quotbuffer,&quot an array is a contiguously allocated set of objects called elements. An array has a definite size, that is, a definite number of elements are allocated to it. The software should not use the array name to access anything outside the boundary of the allocated elements. The elements are all of the same data type and are accessed by integer offsets. If the software can utilize the array name (more generally, array handle) to access any memory other than the allocated objects, it falls into this class. An array could be pictured as follows: Type Low-level, e.g., language dependent. Taxonomy The causes, attributes and consequences of the Buffer Overflow (BOF) class are depicted and explained below. Buffer Overflow (BOF) class - click on image for detailed view. Attributes: Access - Read, Write. Boundary - Below, Above. Which end of the array is violated. Synonyms for boundary are side, bound or end. The terms before, under or lower may be used instead of below. The terms after, over or upper may be used instead of above. The term outside indicates that the boundary is unknown or it doesn't matter. Location - Heap, Stack. What part of memory the array is allocated in. It may matter since violations in the stack may affect program execution flow, while violations in the heap typically only affect data values. Other compilers and operating system may have other locations that are significant. For instance, other locations are BSS (uninitialized data), Data (initialized) and Code (text). Magnitude - Small, Moderate, Far. How far outside the boundary the violation extends. Small means just barely outside, e.g. one to a few bytes, moderate means is from eight bytes to dozens and far is hundreds, thousands or more. Data Size - Little, Some, Huge. How much data is accessed beyond the boundary. As in magnitude, these distinctions are important in some cases. For instance, Heartbleed might not have been a severe problem if it just exfiltrated a little data. The fact that it may exfiltrate a huge amount of data greatly increases the chance that very important information will be leaked. Excursion - Continuous, Discrete. Whether the violating access was preceded by consecutive accesses of elements within the array (continuous) or the violation was just accessing outside of the array (discrete). Synonym for excursion is span. Typically string accesses or array copies handle a continuous set of array elements, while a vagrant array index only reads or writes one element. Kratkiewicz defines reach(which we named excursion) as follows: &quotA continuous overflow accesses consecutive elements within the buffer before overflowing past the bounds, whereas a discrete overflow jumps directly out of the buffer.&quot For instance, if an array a has 10 elements, then: accessing sequentially (most probably through a loop) ..., a[7], a[8], a[9], a[10] -- gives us a continuous excursion to a[10] out of the array accessing a[10] directly without sequentially accessing previous array elements -- gives us discrete excursion to a[10] out of the array. The step for sequential access of elements could be greater than one. That is, it may be a[6], a[8], a[10], which is continuous. Access before the beginning would be, e.g., a[2], a[1], a[0], a[-1]. &quotContinuous&quot means that the program constrains accesses to always be consecutive. CVE-201-1773 Chrome WebCore toAlphabeticOrNumeric() converts a number to a sequence of characters with the following loop: while ((numberShadow /= sequenceSize) > 0) {letters[lettersSize - ++length] = sequence[numberShadow % sequenceSize - 1];} (numberShadow is the number to be converted.) The array sequence is accessed &quotat random&quot, that is, depending on the input. There may be an input that leads to accessing sequence[1], then sequence[0], then sequence[-1]. This does not constitute continuous excursion. It is discrete excursion. Any of the attributes may be &quotany,&quot &quotdon't care&quot or &quotunknown.&quot For instance, strict bounds checking is equally effective regardless of the location, magnitude, data size or excursion of the violation. Keeping return addresses in a separate stack helps prevent problems occurring from write accesses when the array location is the stack. Causes Data Exceeds Array Array Too Small The array was allocated smaller than it should have been. This may occur because the programmer leaves out a factor, like the size of a header, uses the wrong variable, or forgets room for a null to terminate a string. Too Much Data More data is accessed than was anticipated. This  may occur because the string is not NULL terminated or the amount of data is calculated differently than the size of the buffer (e.g. heartbleed). Exposition: When we examine code, we can say in some cases that the programmer allocated the array too small, such as in CVE-2015-0235 - Ghost. The code computes the size of a buffer needed, but leaves out one factor, which makes the buffer four bytes short. In other cases, too much data was accessed, such as in CVE-2014-0160 - Heartbleed. A string was stored in an array, but instead of computing the length of the string, the code used a length from the input, which was not checked against the string. This can cause the code to read far more from the buffer than was allocated. In both cases, the size of the data exceeds the size of the array. Just looking at the code, it may be difficult to determine which case it is - it needs semantic content. That's why the two are sub-causes of one cause. Wrong Index / Pointer out of Range Contributing Causes Data Exceeds Array may be caused by an Input [that is] Not Checked Properly [REF] or by an Incorrect Calculation [REF]. The specific cases of Data Exceeds Array are Array Too Small and Too Much Data. Too Much Data may be caused by No NULL Termination [REF]. Wrong Index [or] Pointer Out of Range may be caused by Incorrect Calculation, too, or by an Incorrect Conversion [REF]. The specific cases of Incorrect Calculation are Missing Factor, Incorrect Argument, Off By One, Integer Coercion, Integer Overflow Wrap-around and Integer Underflow. Consequences The graph of consequences shows what could happen due to the fault. The ACI cluster of consequences is the same in all classes where it appears. &quotResource Exhaustion&quot refers to Memory and CPU. Sites BOF may occur at the use of [ ] or the use of unary * operator with arrays in the C language. Sites also include the use of many string library functions, such as strcpy() or strcat(). Related CWEs, SFP and ST CWEs related to BOF are CWE-119, CWE-120, CWE-121, CWE-122, CWE-123, CWE-124, CWE-125, CWE-126, CWE-127, CWE-786, CWE-787, CWE-788. The only related SFP cluster is SFP8 Faulty Buffer Access under Primary Cluster: Memory Access. The corresponding ST is the Buffer Overflow Semantic Template. Application Application examples are provided here. References [1] ISO/IEC 9899:2011 programming languages - C, Committee Draft-April 12, 2011 N1570. The International Organization for Standardization and the International Electrotechnical Commission (ISO/IEC) Joint Technical Committee JTC 1, Information technology, Subcommittee SC 22, Programming languages, their environments and system software interfaces. Working Group WG 14 - C. Tech. Rep. 2011. [2] chromium, Contents of /branches/WebKit/375/WebCore/rendering/RenderListMarker.cpp. Revision 48100. [3] Kendra Kratkiewicz. Evaluating Static Analysis Tools for Detecting Buffer Overflows in C Code. Master's thesis. Harvard University, Cambridge, MA. March 2005.", "tags": "Buffer Overflow BOF", "url": "https://samate.nist.gov/BF/Classes/BOF.html"},

     {"title": "Classes - Injection", "text": "Definition: Due to input with language-specific special elements, the software assembles a command string that is parsed into an invalid construct. In other words, the command string is interpreted to have unintended commands, elements or other structures. Taxonomy The causes, attributes and consequences of the Injection (INJ) class are depicted and explained below. Attributes Language - SQL, Bash, regex, XML/Xpath, PHP, CGI, etc. This indicates the language in which the command string is interpreted. Special Element - Query Elements, Header Separators, Scripting Elements, Format Parameters, Path Traversals, Wildcards, Metacharacters. These could be assembled with other elements to form malicious structures such as queries, scripts and commands. Query elements are strings delimiters ‘ or &quot or words such as ‘and’ or ‘or’. Header separators are carriage return/line feed. Scripting elements are < or > or &. Format parameters are such as %c or %n. Path traversals elements are .. or \. Metacharacters are back tick ( ` ) or $ or &. Entry Point - Data Entry Field, Scripting Tag, Markup Tag, Function Call Parameter, Procedure Call Argument. This indicates where the input came from. Invalid Construct - Database Query, Command, Regular Expression, Markup, Script, etc. This indicates what eventually is wrong. Causes The graph of causes shows that there are two main causes for injection: input not checked properly or input not sanitized properly. Consequences The graph of consequences shows what could happen due to the fault. Note that in the graph of consequences, &quotArbitrary Code Execution&quot concerns any instructions to the computer - compiled, interpreted by software, executed directly by hardware or combination. Note that the ACI cluster of Consequences is the same in all classes where it appears. Sites Injection sites are typically not primitive operations in most languages. Sites are the library or utility functions that accept a command string for actions. In shell commands, command substitution is invoked with paired back quotes (`...`) or $(...). Command substitution executes a subshell, which opens the possibility of the string to be interpreted with all the richness of the command line interpreter. Related CWEs, SFPs and ST CWEs related to INJ are CWE-74, CWE-75, CWE-77, CWE-78, CWE-80, CWE-85, CWE-87, CWE-88, CWE-89, CWE-90, CWE-93, CWE-94, CWE-243, CWE-564, CWE-619, CWE-643, CWE-652. Related SFPs are SFP24 and SFP27 under Primary Cluster: Tainted Input, and SFP17 under Primary Cluster: Path Resolution. The corresponding ST is the Injection Semantic Template. Application Application examples are provided here.", "tags": "INJ", "url": "https://samate.nist.gov/BF/Classes/INJ.html"},

     {"title": "Classes - Control of Interaction Frequency Bugs", "text": "Definition: The software does not properly limit the number of repeating interactions per specified unit. In physics, frequency is the number of occurrences of a repeating event per unit time. Interactions in software could be also per event or per user. Taxonomy The causes, attributes and consequences of the Control of Interaction Frequency Bugs (CIF) class are depicted and explained below. Control of Interaction Frequency Bugs (CIF) class - click on image for detailed view. Attributes Interaction - Authentication Attempt, Book, Checkout, Register, Initiate. This indicates the type of interactions to be controlled. Voting could be related to election, census, survey, referendum and ballot. Booking could be of tickets, hotel rooms or rental cars. Checkout could be of library books, hotel rooms or rental cars. Register could be for computer games. Initiate could be for message exchange. Number - Single, Unique; Specified Number (> 1). This indicates the maximum number of occurrences allowed. Unit - Time Interval, Event, User. This indicates the specific unit per which the number of occurrences is controlled. Time Interval could be in seconds, in days, etc. Event could be election, authentication, on-line transaction to move funds, etc. Authentication event is the sequence of authentication attempts arriving at a particular server, possibly with the same partial credential, from any source, that terminates by successful authentication or by blocking. Actor - User, Part of Program Logic, Automated Process. This indicates who/what is performing the repeating interactions. User could be authenticated user, attacker. Part of program logic could be message exchange. Automated process could be virus, bot. Our taxonomy makes it abundantly clear that CIF is a &quotmetaclass&quot in some senses. External policies must define for each system or application what constitutes an interaction, how many interactions should be allowed, and the unit. Each policy, then, defines a different class of CIF concerns. Causes The graph of causes shows that there are two main causes: number of interactions not checked properly or frequency of interactions not checked properly. Consequences The graph of consequences shows what could happen due to the fault. Note that in the graph of consequences, &quotCredentials&quot concerns username or password, smart card and personal identification number (PIN), retina, iris, fingerprint, etc. &quotResource Exhaustion&quot concerns memory, CPU or granted licenses. Note that the ACI cluster of consequences is the same in all classes where it appears. Sites Since the concept of interaction is so broad and high level, compared to most programming languages, no general description of what is a site is feasible. Each system or application must define its own concept of interaction. An interaction must then be mapped to some code that controls or authorizes said interactions. More importantly, since a failure may be the total lack of code to recognize and control frequency of interaction, there is often no particular line or even block of code that can be pointed out as missing the control code. An entire path may be indicated from the beginning of an interaction event, that is, an outside agent indicates desire to start an interaction, to the final chance in execution flow that code may refuse to authorize the event. Related CWEs and SFPs CWEs related to CIF are CWE-799, CWE-307, CWE-837. The only related SFP cluster is SFP34 Unrestricted Authentication under the Primary Cluster: Authentication. Application Application examples are provided here.", "tags": "CIF", "url": "https://samate.nist.gov/BF/Classes/CIF.html"},

     {"title": "Classes - Encryption/Decryption Bugs", "text": "Definition: Encryption Bugs: The software does not properly transform sensitive data (plaintext) into unintelligible form (ciphertext) using a cryptographic algorithm and key(s). Decryption Bugs: The software does not properly transform ciphertext into plaintext using a cryptographic algorithm and key(s). Note that &quottransform&quot is for confidentiality.&quot Please see also our Model of Cryptographic Store or Transfer. ENC is related to KMN, RND, and IEX. Type High-level, e.g., semantic. Taxonomy The causes, attributes and consequences of the Encryption/Decryption Bugs (ENC) class are depicted and explained below. Encryption Bugs (ENC) class - click on image for detailed view. Attributes Sensitive Data – Credentials, System Data, State Data, Cryptographic Data, Digital Documents. This is secret (confidential) data. Credentials include Password, Token, Smart Card, Digital Certificate, Biometrics (fingerprint, hand configuration, retina, iris, voice.) System Data could be configurations, logs, Web usage. Cryptographic Data is hashes, keys, keying material. Keying material is cryptographic keys, initialization vectors, shared secrets, domain parameters, random bits (seeds, salts, nonces). Data State – Stored, Transferred.This reflects if data is in rest or use, or if data is in transit. Secure store is needed for data that is in rest or use from files (e.g. ini, temp, configuration, log server, debug, cleanup, email attachment, login buffer, executable, backup, core dump, access control list, private data index), directories (Web root, FTP root, CVS repository), registry, cookies, source code & comments, GUI, environmental variables. Secure transfer is needed also for data in transit between processes or over a network. Algorithm – Symmetric, Asymmetric. This is the key encryption scheme used to securely store/transfer sensitive data. Symmetric (secret) key algorithms (e.g. Serpent, Blowfish) use one shared key. Asymmetric (public) key algorithms (e.g. Diffie-Hellman, RSA) use two keys (public, private). Security Service(s) – Confidentiality (and in some modes of encryption Integrity and Identity Authentication). This is the security service that was failed by the encryption process. Confidentiality is the main security service provided by encryption. Those marked with ‘~’ are only for some specific modes of encryption. Causes In the graph of causes, modification of algorithm is remove/change or add a cryptographic step. Improper algorithm or step could be missing, inadequate, weak, risky/broken. Insecure mode of operation leads to weak encryption algorithm. Sites ENC is a high level class, so sites do not apply. Related CWEs and SFPs CWEs related to Encryption (although some are not ENC) are CWE-256, CWE-257, CWE-261, CWE-311, CWE-312, CWE-313, CWE-314, CWE-315, CWE-316, CWE-317, CWE-318, CWE-325, CWE-326, CWE-327, CWE-329, CWE-780. Related SFP clusters are SFP 17.1 Broken Cryptography and SFP 17.2 Weak Cryptography under Primary Cluster: Cryptography. Application Application examples are provided ENC link here.", "tags": "ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC ENC", "url": "https://samate.nist.gov/BF/Classes/ENC.html"},

     {"title": "Classes - Faulty Result", "text": "Definition Operations in the software produce a faulty result due to conversions between primitive types, range violations, or domain violations. The terms &quotrange violation&quot and &quotdomain violation&quot include overflow, underflow, wrap around, round off, divide by zero, and negative shift. Overflow is when the combined value of the two operands exceeds the range of the typed operator [1]. Range violation also includes use of the wrong typed operation [2]. Conversions between primitive types, range violations, and domain violations are all considered to be operand faults. Operations on pointers (memory addresses) are not FRS [3]. Floating point overflow and underflow, conversion between floating point types, and conversion between floating point and integer types are FRS. Numerical analysis errors, such as loss of precision, failure to converge, and conditioning problems, are not FRS. The model is that an operation causes (implicit) conversion of its operands’ values, then the operation is performed. How does argument passing and the C cast fit this model? Argument passing can be seen as an implicit conversion then a null operation (or, equivalently, an identity operation is performed). The C cast can be seen as explicit conversion then null. Type Low (language related) Attributes Result Fault - Overflow (e.g., INT_MAX + 1 or -LONG_MIN), Underflow (e.g., UINT_MIN - 1 or float becomes very tiny, e.g., MIN_POS_FLOAT/2), Undefined (e.g., j/0), Loss of precision (e.g. c = (f - 32) * 5/9; often called rounding. Includes truncation toward zero or fractional part discarded if the programmer expected rounding), Truncation (that is, cut off information that does not fit, e.g. int = long), Distortion (e.g. unsigned = negative_number) The attribute &quotResult Fault&quot indicates what resulted because of the fault. Wraparound is expressed as either overflow (value became too large) or underflow (value became less than the least expressible value). Operation - The operations are arithmetic (e.g. +, /, %, --, unary -), bitwise shift (>> and <<), assignment (e.g. =, +=), explicit conversion (cast), and argument passing in a function call. Although the attribute is named OperaTION, usually the operaTOR is written. We use &quotoperator&quot to mean the syntactic representation and &quotoperation&quot to mean the function that is executed. For example, the operator &quot+&quot corresponds to the addition operation. The distinction is like that between a numeral and a number. Operand Error - Value exceeds type (Superset of Value too big and Type too small. Yields Overflow, Underflow, or Truncation), Inadequate type (Yields Loss of precision, Underflow, or Distortion), Domain error (Yields Undefined) Operand Error specifies what the problem is with the operands. This is typically a relationship between operands of the operation, not just the characteristic of one operand. &quotValue exceeds type&quot is a superset comprised of two conditions: &quotvalue too big&quot and &quottype too small&quot. How does one determine which condition it is? One must consider the context, that is, the programmer’s intent or what a correct program should do. In some cases, the operand value was just too big and should have been rejected (suggests Input Not Checked Properly). In other cases, the result should have been handled, so the type should have been larger (suggests Programmer Error). Type(s) - int, double, long int -> short, unsigned x unsigned -> unsigned, etc. This is the type(s) of the operand(s) and/or the result. Unary -, ++, etc. may overflow. So some FRSs have only one operand and one type. Magnitude - Small, Moderate, Large. The attribute &quotMagnitude&quot indicates how far out of range it was. Small is an overflow by one or two. Moderate is half a dozen. Large is hundreds. The actual values of the attribute are continuous; partitioning the values into three discrete intervals is somewhat arbitrary. Excursion - Continuous, Discrete. The attribute &quotExcursion&quot indicates whether the out-of-range condition occurred because of continuous steps, which went out, or it was one step. Increments, especially in a loop, indicate continuous. For example, i++; j += 2; Other computations indicate discrete excursion. For example (from CVE-2016-2326), pts + pkt->duration * 10000 Causes Input Not Checked Properly {Programmer Error} Consequences Infinite Loop (CWE-128, CWE-190, CWE-191, CWE-192) DoS: crash / exit / restart (CWE-196) DoS: resource consumption (CPU; memory) (CWE-195, CWE-681) DoS: instabilityBOF via Data Exceeds Array or  Wrong Index / Pointer Out Of Range ( CWE-128, CWE-190, CWE-191, CWE-192, CWE-194, CWE-195, CWE-196) Sites Any use of the operators listed under the Operation attribute, which include explicit conversion (cast) and passing arguments in a function call. Relational and equality test operators (e.g. <, !=) are not sites. Although the usual arithmetic conversions occur to compare operands, this never results in overflow, range violation, etc. (I think). The conditional operator (?:) is not a site, either. A common type is chosen for the result of the operator by performing the usual arithmetic conversion on the two operands of the colon (that is, for a ? b : c, it is between b and c), but this never results in FRS (I think). The bitwise operators &, |, ~, and ^ are not sites. The reasons are the same as others. The C comma operator (,) never causes conversion, and therefore is not a site. The C logical operators, which are &&, ||, and !, never cause conversion, and therefore are not sites. The basic assignment operator (=) is a site since the lefthand side may not be able to hold the value of the righthand side. Draft C Secure Coding Rules N1579 (2011) Table 7 (Sect. 5.45, page 69 - PDF page 77) lists every operator and whether or not it can overflow. (WG14 Document: N1579, ISO/IEC JTC 1/SC SC 22 N 1579, Draft 2011-09-20, http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1579.pdf) Related CWEs, SFP and ST and SEI/CERT Rules and Recommendations CWEs related to FRS are CWE-128, CWE-136, CWE-189, CWE-190, CWE-191, CWE-192, CWE-194, CWE-195, CWE-196, CWE-197, CWE-369, CWE-681, CWE-682, CWE-704. Related SFP secondary cluster is Glitch in Computation (CWE-998). There is no related ST. Related SEI/CERT Rules and Recommendations are Rule 04 (C), (aka CWE-738), INT30-C, INT31-C, INT32-C, INT33-C, INT34-C, INT35-C, INT36-C; Rule 5 (C) (aka CWE-739), FLP03-C, FLP32-C, FLP34-C, FLP36-C; Rule 07 (C) (aka CWE-741), STR34-C, STR37-C; Rec. 04 (C) INT01-C, INT02-C, INT04-C, INT05-C, INT07-C, INT08-C, INT10-C, INT12-C, INT13-C, INT14-C, INT15-C, INT16-C, INT18-C; Rec. 08 (C) (aka CWE-742), MEM07-C; Rule 03 (C++) (aka CWE-872), INT50-CPP; Rule 03 (Java) (aka CWE-848), NUM00-J, NUM01-J, NUM02-J, NUM03-J, NUM04-J, NUM08-J, NUM12-J, NUM13-J, NUM14-J. Examples CVE-2011-4093 Fix: use lowest available ID instead of always using next higher. CVE-2012-5143 Fix: rearrange computation to avoid chance of overflow CVE-2016-5221 Fix: check (value computed) for value too big Notes On the term &quotprimitive types&quot C11 calls them &quotbasic types&quot (http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf 6.2.5 Types &quot14 The type char, the signed and unsigned integer types, and the floating types are collectively called the basic types.&quot Accessed January 2017) Java SE 8 calls them &quotprimitive types&quot (https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf 1.1 Organization of the Specification &quotThe primitive types are ... various sizes of two's-complement integers, single- and double-precision IEEE 754 standard floating-point numbers, a boolean type, and a Unicode character char type.&quot Accessed January 2017) C# 4.0 calls them &quotsimple types&quot  (https://www.microsoft.com/en-us/download/details.aspx?id=7029 1.3 Types and variables The table shows that simple types comprise Signed integral, Unsigned integral, Unicode characters, IEEE floating point, High-precision decimal, and Boolean. Simple types do not include Enum types. Accessed January 2017) Justification: We use &quotoperations&quot instead of &quotan operation&quot because we often consider the assignment operator together with the binary (and other) operators that produce the result, e.g., a = b + c; Explanation: Although we use the plural (e.g. &quotoperations&quot, &quotconversions&quot, &quotprimitive types&quot), there may be only one operator or there may be only one conversion of the value of one operand. Explanation: Except in case of range and domain violations (e.g. overflow because of addition or undefined because of divide by zero), the fault occurs during the conversion, not during the operation. Thus the class might be called &quotFaulty Conversion&quot. But that name could lead readers to think only of the explicit cast operator, and the vast majority of faulty conversions are implicit conversions associated with operations. Explanation: If the programmer meant to subtract, but wrote &quot+&quot, it is a bug, not FRS. Additional note: The C standard [ISO/IEC 9899:2011, 7.12.1] distinguishes three types of faults: domain error, pole error, and range error. We lump these all into range or domain violation. (There is a summary of these three in SEI/CERT Rule FLP32-C.) [1] Overflow can be viewed as a domain violation. Think of a binary operator, say +, as a unary operator (call it pair+) that takes a pair (of numbers). Just as division handles many numbers, but not zero, this pair+ operator handles many inputs (pairs of numbers), but not all. The domain of pair+ is then the pairs of numbers whose sum does not overflow. The plus operator, +, represents a set of summing operations. Different operations are chosen depending on operand types. Thus &quot+&quot in a + b is taken to mean short+short if a and b are short, int+int if one is short and the other is int, and so forth. Each operation produces a result of a certain type. Note: the compiler inserts a conversion in some cases. Consider this example: short a; int b; int c = a + b; [2] Use of an operation of the wrong type can be viewed as a range violation. Consider this example of a faulty Fahrenheit to Centigrade conversion: float f; float c = (f - 32) * 5/9; Since both operands of &quot/&quot are integers, the compiler selects integer division, resulting in Loss of Precision fault. The division takes place, the result is between the maximum and minimum integer, but the operation does not produce the resolution (precision) desired. This occurs in CVE-2016-5223. Conceivably, there could be too much resolution. Consider this example of computing the number of reams of paper needed: constant int sheetsPerReam = 500; int reams = +(sheetsNeeded + sheetsPerReam - 1) / sheetsPerReam; In C99 and later, integer division truncates toward zero. If floating point division were done, then rounded, it would not do what we want. So sheetsNeeded must be int or cast to int. If sheetsNeeded changed to be float, floating point division is performed instead of integer division. [3] Why are pointer (memory address) operations not FRS? Observe that only relational, equality, and only a few additive operations (e.g. >, !=, +, --) are defined for pointers because pointer arithmetic mimics array accesses. In particular, pointer / int and pointer + pointer are not defined. (However, pointer - pointer is defined if the pointers are to the same allocation.) ", "tags": "FRS", "url": "https://samate.nist.gov/BF/Classes/FRS.html"},

     {"title": "Model of Cryptographic Store or Transfer", "text": "Cryptography Cryptography is a broad, complex, and subtle area. It incorporates many clearly separate processes, such as encryption/decryption, verification of data or source, and key management. There are bugs if the software does not properly transform data into unintelligible form, verify authenticity or correctness, manage keys, or perform other related operations. Some transformations require keys, for example encryption and decryption, while others do not, for example secret sharing. Authenticity covers integrity of data, identity of data source, origin for non-repudiation, and content of secret sharing. Correctness is verified for uses such as zero-knowledge proofs. Cryptographic processes use particular algorithms to achieve particular security services. Examples of attacks are spoofing messages, brute force attack, replaying instructions, timing attack, chosen plaintext attack, chosen ciphertext attack, and exploiting use of weak or insecure keys. We use cryptographic store or transfer to illustrate our ENC, VRF, and KMN classes of bugs. Note that these classes may appear in many other situations such as self-sovereign identities, block ciphers, and threshold cryptography. We focus on transfer (or store) because it is well known and it is what most people think of when &quotcryptography&quot is mentioned. We define bugs in cryptographic store or transfer as: The software does not properly encrypt/decrypt, verify, or manage keys for data to be securely stored or transferred. Our Model A modern, secure, flexible cryptographic storage or transfer protocol likely involves subtle interaction between encryption, verification, and key management processes. It may involve multiple stages of agreeing on encryption algorithms, establishing public and private keys, creating session keys, and digitally signing texts for verification. Thus, encryption may use key management, which itself uses encryption and verification. The following figure presents a model of these recursive interactions and where potentially the corresponding ENC, VRF, KMN, and other BF bugs could happen. The rounded rectangles indicate the boundaries of the classes. The dashed ones show sending and receiving entities Our Model of Cryptographic Store or Transfer Bugs. Encryption may occur in tandem with Verification or it may precede Verification serially, if the ciphertext is signed or hashed. Encryption uses Key Management, and Key Management likely uses Encryption and Verification to handle keys - click on image for detailed view. KMN is a class of bugs related to key management. Key management comprises key generation, selection, storage, retrieval and distribution, and determining and signaling when keys should be abandoned or replaced. A particular protocol may use any or all of these operations. Key management could be by a third party, the source, or the user - thus the KMN area intersects the Source and User areas. A third-party certificate authority (CA) distributes public keys in signed certificates. Key management often uses a recursive round of encryption and decryption, and verification to establish a shared secret key or session key before the actual plaintext is handled. ENC is a class of bugs related to encryption and decryption. Encryption is by the source, decryption is by the user. The encryption/decryption algorithm may be symmetric, that is uses the same key for both, or asymmetric, which uses a pair of keys, one to encrypt and the other to decrypt. Public key cryptosystems are asymmetric. Ciphertext may be sent directly to the user, and verification accompanies it separately. The red line is a case where plaintext is signed or hashed and then encrypted. VRF is a class of bugs related to verification. Verification takes a key and either plaintext or ciphertext, signs or hashes it, then passes the result to the user. The user uses the same key or the other key from the key-pair to verify data integrity or source. Note that hash alone without any other mechanism cannot be used to verify source or to protect data integrity against attackers. However, it can be used to protect data integrity against channel errors. In the cases of symmetric encryption, one secretly shared key (shKey) is used. The source encrypts with shKey, and the user decrypts also with shKey. In the cases of asymmetric encryption, pairs of mathematically related keys are used. The source pair is pbKeySrc and prKeySrc; the user pair is pbKeyUsr and prKeyUsr. The source encrypts with pbKeyUsr and signs with prKeySrc. The user decrypts with prKeyUsr and verifies with pbKeySrc.", "tags": "CRY", "url": "https://samate.nist.gov/BF/Classes/CRY.html"},

     {"title": "Classes - Verification Bugs", "text": "Definition: The software does not properly sign data, check and prove source, or assure data is not altered. Note that &quotcheck&quot is for identity authentication, &quotprove&quot is for origin (signer) non-repudiation, and &quotnot altered&quot is for integrity authentication. VRF is related to KMN, RND, ENC, Authentication (ATN), IEX. Type High-level, e.g., semantic. Taxonomy The causes, attributes and consequences of the Verification Bugs (VRF) class are depicted and explained below. Verification Bugs (VRF) class - click on image for detailed view. Attributes Verified Data - Secret, Public. This is the data that needs verification. It may be confidential or public. Secret (confidential) data could be cryptographic hashes, secret keys, or keying material. Public data could be signed contract, documents, or public keys. Algorithm - Hash Function + RND, message authentication code (MAC), Digital Signature. Hash functions are used for integrity authentication. They may use RND. MAC are symmetric key algorithms (one secret key per source/user), used for integrity authentication, identity authentication. It needs authentication code generation, source signs data, user gets tag for key and data, and verifies data by tag and key. Digital Signature is an asymmetric key algorithm (two keys), used for integrity and identity authentication, and origin (signer) non-repudiation. It needs key generation, signature generation, and signature verification. MAC and Digital Signature use KMN and recursively VRF. Security Service - Data Integrity Authentication, Identity Authentication, Origin (Signer) Non-Repudiation. This is the security service the verification process failed. Integrity Authentication is for data and keys. Identity Authentication and Origin Non-Repudiation are for source authentication. Sites VRF is a high level class, so sites do not apply. Related CWEs and SFPs CWEs related to Encryption (although some are not VRF) are CWE-256, CWE-296, CWE-347 The related SFP cluster is SFP 17.2 Weak Cryptography under Primary Cluster: Cryptography Application Application examples are provided here.", "tags": "VRF", "url": "https://samate.nist.gov/BF/Classes/VRF.html"},

     {"title": "Classes - Key Management Bugs", "text": "Definition: The software does not properly generate, store, distribute, use, or destroy cryptographic keys and other keying material. KMN is related to ENC, RND, VRF, IEX. Type High-level, e.g., semantic. Taxonomy The causes, attributes and consequences of the Key Management Bugs (KMN) class are depicted and explained below. Key Management Bugs (KMN) class - click on image for detailed view. Attributes Cryptographic Data - Hashes, Keying Material, Digital Certificate. Algorithm - Hash Function + RND, MAC, Digital Signature, etc. Different cryptosystems have their own specific algorithm(s). Operation - Generate/Select, Store, Distribute, Use, Destroy. This is the failed operation. Store includes update and recover. Distribute includes key establishment, transport, agreement, wrapping, encapsulation, derivation, confirmation, shared secret creation; uses ENC and KMN (reclusively). KMN is a high level class, so sites do not apply. Related CWEs, SFP and ST CWEs related to KMN are CWE-321, CWE-322, CWE-323, CWE-324. The related SFP clusters areSFP 17.2 Weak Cryptography under Primary Cluster: Cryptography and SFP 4.13 Digital Certificate under Primary Cluster: Authentication. Note that, some of the CWEs listed in 17.2 are not KMN.", "tags": "KMN", "url": "https://samate.nist.gov/BF/Classes/KMN.html"},

     {"title": "Examples - Buffer Overflow", "text": "CVE-2014-0160 (Heartbleed) BF Taxonomy Cause: Input not checked properly leads to Data Exceeds Array (specifically Too Much Data) Attributes: Access: Read Boundary: Above Location: Heap Data Size: Huge Excursion: Continuous Consequence: IEX (if not had been cleared - CWE-226) BF Description &quotInput not checked properly leads to too much data, where huge data is read from the heap in a continuous excursion above the array boundary, which may be exploited for IEX (if not had been cleared).&quot [2] CVE Description &quotThe (1) TLS and (2) DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug.&quot [1] Analysis The following analysis is based on information in [1,3,4,5]. A user has to send to the software data, and a number called payload that is the length of that data. The software has to send the data received back to the user. In the Heartbleed attack, a malicious user gives payload a value that can be as large as 65535+1+2+16, and sends data having a number of bytes that is much less than payload, and can be as small as 1. The software stores that data in an array that it allocated for that purpose. The size of that array is much less than 65535+1+2+16. The software does not check the data and the value of payload in order to make sure that the number of bytes of data is equal to payload. The software therefore assumes that those numbers are equal. The software reads, using memcpy, payload consecutive bytes from that array, beginning at its first byte, (continuous excursion) and sends them to the malicious user. This results in reading a large number of bytes beyond the end of the allocated array. The software did not clear the memory that it read from beyond the allocated array. Therefore, the data read and sent to the malicious user by the software includes sensitive information. Source Code CVE-2015-0235 (Ghost) BF Taxonomy Cause: Incorrect Calculation (Missing Factor) leads to Array Too Small Attributes: Access: Write Boundary: Above Location: Heap Data Size: Some Excursion: Continuous Consequence: Arbitrary Code Execution leading to DoS BF Description &quotIncorrect calculation (missing factor) leads to array too small, where some data is written to the heap in a continuous excursion above the array boundary, which may be exploited for arbitrary code execution, leading to DoS.&quot [2] CVE Description &quotHeap-based buffer overflow in the __nss_hostname_digits_dots function in glibc 2.2, and other 2.x versions before 2.18, allows context-dependent attackers to execute arbitrary code via vectors related to the (1) gethostbyname or (2) gethostbyname2 function, aka GHOST.&quot [6] Analysis The following analysis is based on information in [6,7,8]. The number of bytes that can be overwritten is sizeof (char *), which is 4 bytes on a 32 bit machine, and 8 bytes on a 64 bit machine. In a calculation of the size needed to store certain data, the size of a char pointer is missing, resulting in array too small. Buffer over write is done by strcpy (continuous excursion). Qualys developed an attack on the Exim mail server, exploiting this vulnerability, as proof of concept. This attack uses an initial buffer over write to enlarge the number in the size field of a portion of memory that is available for the next allocation. This modification enables a subsequent over write that enables write-anything-anywhere, which in turn enables over writing Exim's Access Control Lists, which in turn enables arbitrary code execution. Source Code Code With Bug Code With Fix CVE-2010-1773 (Chrome WebCore) BF Taxonomy Cause: Incorrect calculation, (off by one) leads to a wrong index Attributes: Access: Read Boundary: Below Location: Heap Data Size: Little Excursion: Discrete Consequence: Information exposure, arbitrary code execution or program crash, leading to DoS BF Description &quotIncorrect calculation, (off by one) leads to a wrong index, where little data is read from the heap in a discrete excursion below the array boundary, which may be exploited for information exposure, arbitrary code execution or program crash, leading to DoS.&quot [2] CVE Description &quotOff-by-one error in the toAlphabetic function in rendering/RenderListMarker.cpp in WebCore in WebKit before r59950, as used in Google Chrome before 5.0.375.70, allows remote attackers to obtain sensitive information, cause a denial of service (memory corruption and application crash), or possibly execute arbitrary code via vectors related to list markers for HTML lists, aka rdar problem 8009118.&quot [9] Analysis The following analysis is based on information in [9,10,11,12,13,14,15,16].The software reads in a loop from an array, where the sequence of indices of array elements read is neither necessarily monotonic nor necessarily having a fixed distance between consecutive elements. That index should be the remainder obtained by dividing an integer by an integer. The software subtracts 1 from that remainder, which is wrong, and can result in the index being equal to -1, leading to reading from an address that is below the beginning of the array by 1. Consequences are mentioned in [10], and [16] includes &quotAn off by one memory read out of bounds issue exists in WebKit's handling of HTML lists. Visiting a maliciously crafted website may lead to an unexpected application termination or the disclosure of the contents of memory.&quot Source Code Code With Bug Code With Fix CVE-2015-2282 BF Taxonomy Cause: Input not checked properly leads to wrong index Attributes: Access: Write Boundary: Above Location: Heap Data Size: Some Excursion: Continuous Consequence: Arbitrary code execution or program crash, which can lead to DoS BF Description &quotInput not checked properly leads to wrong index, where some data is written to the heap in a continuous excursion, above the array boundary, which can cause arbitrary code execution or program crash, which can lead to DoS.&quot [19] CVE Description &quotStack-based buffer overflow in the LZC decompression implementation (CsObjectInt::CsDecomprLZC function in vpa106cslzc.cpp) in SAP MaxDB 7.5 and 7.6, Netweaver Application Server ABAP, Netweaver Application Server Java, Netweaver RFC SDK, GUI, RFC SDK, SAPCAR archive tool, and other products allows context-dependent attackers to cause a denial of service (crash) or possibly execute arbitrary code via unspecified vectors, aka SAP Security Note 2124806, 2121661, 2127995, and 2125316.&quot [17] Analysis [17, 18, 19, 20] include sufficient information for describing this CVE using BF. Note that this buffer resides in the Heap even though it implements a stack data structure. Source Code Code With Bug Code With Fix CVE-2015-2278 BF Taxonomy Cause: Input not checked properly leads to wrong index Attributes: Access: Read Boundary: Above or Below Data Size: Some Excursion: Discrete Consequence: DoS BF Description &quotInput not checked properly leads to wrong index, where some data is read in a discrete excursion, above or below the array boundary, which can lead to DoS.&quot CVE Description &quotThe LZH decompression implementation (CsObjectInt::BuildHufTree function in vpa108csulzh.cpp) in SAP MaxDB 7.5 and 7.6, Netweaver Application Server ABAP, Netweaver Application Server Java, Netweaver RFC SDK, GUI, RFC SDK, SAPCAR archive tool, and other products allows context-dependent attackers to cause a denial of service (out-of-bounds read) via unspecified vectors, related to look-ups of non-simple codes, aka SAP Security Note 2124806, 2121661, 2127995, and 2125316.&quot [21] Analysis [18, 21, 22] include sufficient information for describing this CVE using BF. Source Code Code With Bug Code With Fix References [1] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2014-0160. [2] Irena Bojanova, Paul E. Black, Yaacov Yesha, and Yan Wu, The Bugs Framework (BF): A Structured Approach to Express Bugs, QRS 2016, Vienna, Austria. [3] S. Cassidy. Diagnosis of the OpenSSL Heartbleed, Mon 07 April 2014. [4] WIKIPEDIA, The Free Encyclopedia, Heartbleed. [5] The MITRE Corporation, CWE Common Weakness Enumeration, CWE-126 Buffer Over-read. [6] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2015-0235. [7] Openwall, bringing security into open environment, Qualys Security Advisory CVE-2015-0235, 27 January 2015. [8] Qualys Security Advisory CVE-2015-0235. [9] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2010-1773. [10] Robin Gandhi, Buffer Overflow Semantic template CVE-2010-1773. [11] Tracker, Issue 44955. [12] chromium, Diff of /branches/WebKit/375/WebCore/rendering/RenderListMarker.cpp. Revision 48099. [13] chromium, Contents of /branches/WebKit/375/WebCore/rendering/RenderListMarker.cpp. Revision 44321. [14] chromium, Contents of /branches/WebKit/375/WebCore/rendering/RenderListMarker.cpp. Revision 48100. [15] webkit, Fix for Crash in WebCore::toAlphabetic() while running MangleMe -and corresponding- https://bugs.webkit.org/show_bug.cgi?id=39508. Reviewed by Darin Adler. [16] Hat Bugzilla - Bug 596500- (CVE-2010-1773) CVE-2010-1773 WebKit: off-by-one memory read out of bounds vulnerability in handling of HTML lists. [17] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2015-2282. [18] Core Security, SAP LZC LZH Compression Multiple Vulnerabilities. (referenced in [17] and [21]). [19] SourceArchive, SAP AG, vpa106cslzc.cpp (reference 12 in [18]). [20] SourceArchive, SAP AG, hpa106cslzc.h. [21] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2015-2278. [22] SourceArchive, SAP AG, vpa108csulzh.cpp. (reference 13 in [18]). [23] sourceware, blobdiff.", "tags": "Buffer Overflow BOF", "url": "https://samate.nist.gov/BF/Examples/BOF.html"},

     {"title": "Examples - Injection", "text": "CVE 2007-3572 (Yoggie Pico) BF Taxonomy Cause: Input not checked properly (incomplete blacklist) Attributes: Language: CGI Special Element: Shell Metacharacters (back ticks ` ) Entry Point: Function Parameter (&quotparam&quot) Invalid Construct: Command (command within a Ping command) Consequence: Add command, leading to arbitrary code execution and potentially complete host takeover (by adding a Ping command to change the root password) BF Description &quotInput not checked properly (incomplete blacklist) allows Shell metacharacters (back ticks ` ) through a function parameter (&quotparam&quot) in a CGI script and assembly of a string that is parsed into an invalid command construct (command within a Ping command), which may be exploited to add command, leading to arbitrary code execution and potentially complete host takeover (by adding a Ping command to change the root password).&quot [2] This is a shell command injection CVE Description &quotIncomplete blacklist vulnerability in cgi-bin/runDiagnostics.cgi in the web interface on the Yoggie Pico and Pico Pro allows remote attackers to execute arbitrary commands via shell metacharacters in the param parameter, as demonstrated by URL encoded &quot`&quot (backtick) characters (%60 sequences).&quot [1] Analysis The following analysis is based on information in [1,3,4]. Injecting backticks that are not sanitized enables adding a shell command in a CGI script. Complete Host takeover is possible by using backtick to execute changing the file /etc/shadow to include an arbitrary password selected by the attacker. Then the attacker can use that password to login as root. The Ping command was not expected to include a &quotcommand within a (Ping) command&quot, but the backticks (special elements) result in that unexpected structure. Source Code Code With Bug Code With Fix CVE 2008-5817 BF Taxonomy Cause: Input not checked properly or input not sanitized properly Attributes: Language: SQL Special Element: Query Elements (single quote ' , the word or, and equality sign =) Entry Point: Data Entry Fields (&quotusername&quot & &quotpassword&quot) Invalid Construct: Database Query Consequence: Authentication loss, admin server access, and arbitrary code execution BF Description &quotInput not checked properly or input not sanitized properly allows query elements (single quote ' , the word or, and equality sign =) through data entry fields (&quotusername&quot & &quotpassword&quot) in a PHP script and assembly of a string that is parsed into an invalid database query construct, which may be exploited to mask legitimate SQL commands, leading to authentication loss, admin server access, and arbitrary code execution. [2] This is SQL Injection CVE Description &quotMultiple SQL injection vulnerabilities in index.php in Web Scribble Solutions webClassifieds 2005 allow remote attackers to execute arbitrary SQL commands via the (1) user and (2) password fields in a sign_in action.&quot [5] Analysis The following analysis is based on information in [5,6,7]. According to [7], ' or ' 1=1 is used to mask password checking and login as admin. [8] includes an explanation of this type of SQL injection. Source Code Code With Bug Code With Fix References [1] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2007-3572. [2] Irena Bojanova, Paul E. Black, Yaacov Yesha, and Yan Wu, The Bugs Framework (BF): A Structured Approach to Express Bugs, QRS 2016, Vienna, Austria. [3] The MITRE Corporation, CWE Common Weakness Enumeration, CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'). [4] Yoggie Pico Pro Remote Code Execution [5] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2008-5817. [6] CXSESECURITY, webClassifieds 2005 (Auth Bypass) SQL Injection Vulnerability CWE-89 CVE-2008-5817. [7] The MITRE Corporation, CWE Common Weakness Enumeration, CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'). [8] Bricks, SQL injection. [9] ] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2008-5734. [10] SecurityFocus, Merak Mail Server and Webmail Email Message HTML Injection Vulnerability. [11] The MITRE Corporation, CWE Common Weakness Enumeration, CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting').", "tags": "INJ", "url": "https://samate.nist.gov/BF/Examples/INJ.html"},

     {"title": "Examples - Control of Interaction Frequency Bugs", "text": "CVE-2002-0628 BF Taxonomy Cause: Failure to Limit Attributes: Interaction: Authentication Attempt Number: Specificed Number Unit: Authentication Event Actor: User(s) Consequence: Credentials compromise (username or password) BF Description: &quotFailure to limit to a specified number the authentication attempts per authentication event by same or different user(s) may be exploited for credentials compromise (username or password) via brute force.&quot [2] CVE Description &quotThe Telnet service for Polycom ViewStation before 7.2.4 does not restrict the number of failed login attempts, which makes it easier for remote attackers to guess usernames and passwords via a brute force attack.&quot [1] Analysis [1,3] include sufficient information for describing this CVE using BF. Source Code Code With Bug Code With Fix CVE-2002-1876 BF Taxonomy Cause: Failure to recognize repeated interactions leads to failure to properly limit Attributes: Interaction: Authentication Attempt Number: Specificed Number Unit: Specfied Time interval Actor: Authenticated Users Consequence: Resource exhaustion (consumption of all granted licenses) leading to DoS BF Description: &quotFailure to recognize repeated interactions that are rapid initiations of message exchange requests from authenticated users, leads to failure to properly limit them to a specified number per specified time interval, which may be exploited for resource exhaustion (consumption of all granted licenses) leading to DoS.&quot [2] CVE Description &quotMicrosoft Exchange 2000 allows remote authenticated attackers to cause a denial of service via a large number of rapid requests, which consumes all of the licenses that are granted to Exchange by IIS.&quot [4] Analysis [4] includes sufficient information for describing this CVE using BF. Source Code Code With Bug Code With Fix CVE-2002-1018 BF Taxonomy Cause: Failure to limit Attributes: Interaction: Checkout Number: Single Unit: User Actor: User Consequence: Resource exhaustion (consumption of all granted licenses) leading to DoS BF Description &quotFailure to limit the checkouts of a book to a single one per user may be exploited for resource exhaustion leading to DoS.&quot [2] CVE Description &quotThe library feature for Adobe Content Server 3.0 does not verify if a customer has already checked out an eBook, which allows remote attackers to cause a denial of service (resource exhaustion) by checking out the same book multiple times.&quot [5] Analysis [5] includes sufficient information for describing this CVE using BF. Source Code Code With Bug Code With Fix References [1] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2002-0628. [2] Irena Bojanova, Paul E. Black, Yaacov Yesha, and Yan Wu, The Bugs Framework (BF): A Structured Approach to Express Bugs, QRS 2016, Vienna, Austria. [3] The MITRE Corporation, CWE Common Weakness Enumeration, CWE-307: Improper Restriction of Excessive Authentication Attempts. [4] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2002-1876. [5] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2002-1018.", "tags": "CIF CIF", "url": "https://samate.nist.gov/BF/Examples/CIF.html"},

     {"title": "Examples - Encryption/Decryption Bugs", "text": "CVE-2002-5460 BF Taxonomy Cause: Weak Encryption Algorithm (XOR xipher with fixed key) Attributes: Sensitive Data: Credentials (PINs/passwords) Data State: Transferred (over network) Algorithm: Symmetric (that allows obtaining shared key, by sniffing or spoofing the docking process, and decryption) Security Service: Confidentiality Consequence: IEX of Sensitive Data credentials BF Description Use of weak encryption algorithm (XOR cipher with fixed key) allows obtaining the shared symmetric key (by sniffing or spoofing the docking process) and decryption of transferred (over network) credentials (PINs/passwords), which is confidentiality failure and IEX of sensitive data (PINs/passwords). [1] CVE Description &quotMicrosoft ActiveSync 4.1, as used in Windows Mobile 5.0, uses weak encryption (XOR obfuscation with a fixed key) when sending the user's PIN/Password over the USB connection from the host to the device, which might make it easier for attackers to decode a PIN/Password obtained by (1) sniffing or (2) spoofing the docking process.&quot [2] Analysis The following analysis is based on information in [2, 3, 4]): Using electronic codebook (ECB) results in weak encryption, that is a case of deterministic encryption, where patterns in plaintext become evident in the ciphertext. Source Code Code With Bug Code With Fix CVE-2002-1697 BF Taxonomy Causes: Insecure mode of operation (ECB) leads to Weak Encryption Algorithm(for same shared key produces same ciphertext from same plaintext) Attributes: Sensitive Data: Any (Credentials, Cryptographic, ...) Data State: Transferred (over network) Algorithm: Symmetric (that allows identifying patterns and data recovery) Security Service: Confidentiality Consequence: IEX of Sensitive Data BF Description Use of insecure mode of operation (ECB) leads to weak symmetric encryption algorithm (for same shared key produces same ciphertext from same plaintext) that allows identifying patterns and recovery of transferred (over network) sensitive data, which is confidentiality failure and IEX of that sensitive data. [5] CVE Description &quotElectronic Code Book (ECB) mode in VTun 2.0 through 2.5 uses a weak encryption algorithm that produces the same ciphertext from the same plaintext blocks, which could allow remote attackers to gain sensitive information.&quot [6] Analysis The following analysis is based on information in [6, 7, 8]): The encryption algorithm uses XOR with a fixed key. Using a random one time pad with XOR would be fine, while reusing bits of a key with XOR results in weak encryption. Source Code Code With Bug Code With Fix References [1] Bojanova, I., Black, P. E., Yesha, Y., Wu, Yan, Evans, Z., Poster: The Bugs Framework (BF) – First Classes: Buffer Overflow (BOF), Injection (INJ), Control of Interaction Frequency (CIF), STC 2017, NIST, Gaithersburg, MD, USA. [2] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2007-5460. [3] BUGTRAQ:20071015 SYMSA-2007-010: Microsoft ActiveSync 4.x Weak Password Obfuscation. [4] Wikipedia, XOR cipher. [5] The MITRE Corporation CVE-2002-1697. [6] Wikipedia, RSA (cryptosystem). [7] Seclists, Security weaknesses of VTun. [8] Wikipedia, Deterministic encryption.", "tags": "ENC", "url": "https://samate.nist.gov/BF/Examples/ENC.html"},

     {"title": "Examples - Verification Bugs", "text": "CVE-2001-1585 BF Taxonomy Cause: Missing Verifcation Step (challenge-response) in public key authentication Attributes: Verified Data: Any Secret/Public Data State: Transferred (over network) Algorithm: Digital Signature (not using such allows private key not to be verified by public key) Security Service: Identity Authentication Consequence: IEX BF Description Missing verification step (challenge-response) in public key authentication allows private key for digital signature not to be verified by public key, which leads to identity authentication failure and may be exploited for IEX. [1] CVE Description &quotSSH protocol 2 (aka SSH-2) public key authentication in the development snapshot of OpenSSH 2.3.1, available from 2001-01-18 through 2001-02-08, does not perform a challenge-response step to ensure that the client has the proper private key, which allows remote attackers to bypass authentication as other users by supplying a public key from that user's authorized_keys file.&quot [2] Analysis The following analysis is based on information in [3, 4]: Source Code Code With Bug Code With Fix CVE-2015-2141 BF Taxonomy Cause: Modification of Verification Algorithm by adding a step (blinding) Attributes: Verified Data: Any Secret/Public Data State: Transferred (over network) Algorithm: Digital Signature (Rabin-Williams) (that allows obtaining the private key in cases of incorrect unblinding) Security Service: Identity Authentication Consequence: IEX BF Description Modification of verification algorithm (digital signature, Rabin-Williams) by adding a step (blinding before signing) allows obtaining the private key in cases of incorrect unblinding, which leads to identity authentication failure and may be exploited for IEX. [1] CVE Description &quotThe InvertibleRWFunction::CalculateInverse function in rw.cpp in libcrypt++ 5.6.2 does not properly blind private key operations for the Rabin-Williams digital signature algorithm, which allows remote attackers to obtain private keys via a timing attack.&quot [5] Analysis The following analysis is based on information in [6, 7]: Having the private key allows an attacker to be authenticated as the owner of that key. The software intends to use blinding to defend against a timing attack, as follows: Instead of signing the data directly, the data is first transformed using a secret random value (blinding) and then is digitally signed using a private key. At the end, the effect is removed (unblinding), so that there is signed data as if no transformation took place. See [6, 7] for blinding used for RSA. The flaw in this CVE is in doing blinding/ unblinding incorrectly, so that in some cases the effect of the transformation is not removed from the data. This enables the attacker to use the transformed data to recover the private key using a mathematical calculation as described in [6]. In [6] it is observed that if the secret random integer used to transform the message is a quadratic residue modulo an appropriate integer, then the unblinding step correctly undoes the transformation. The fix in [20] assures that the integer is such a quadratic residue. Source Code Code With Bug Code With Fix References [1] Bojanova, I., Black, P. E., Yesha, Y., Wu, Yan, Evans, Z., Poster: The Bugs Framework (BF) – First Classes: Buffer Overflow (BOF), Injection (INJ), Control of Interaction Frequency (CIF), STC 2017, NIST, Gaithersburg, MD, USA. [2] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2001-1585. [3] OpenBSD Security Advisory, Authentication By-Pass Vulnerability in OpenSSH-2.3.1. [4] S. Tatham, PuTTY User Manual – Chapter 8: &quotUsing public keys for SSH authentication.&quot [5] The MITRE Corporation, CVE-2015-2141. [6] Bugzilla – Bug 936435, VUL-0: CVE-2015-2141: libcryptopp: libcrypto++ -- security update. [7] E. Sidorov, &quotBreaking the Rabin-Williams digital signature system implementation in the Crypto++ library.&quot [8] Wikipedia, Blinding Cryptography. [9] Github, Fix for CVE-2015-2141.", "tags": "VRF", "url": "https://samate.nist.gov/BF/Examples/VRF.html"},

     {"title": "Examples - Key Management Bugs", "text": "CVE-2016-1919 BF Taxonomy To be added. BF Description A KMN leads to an ENC. KMN: Use of weak algorithm (eCryptFS-key from password and stored TIMA key) allows generation of keying material (secret key) that can be obtained through brute force, which may be exploited for IEX of keying material (secret key). ENC: KMN fault leads to exposed secret key that allows decryption of stored (on disk) sensitive data, which is confidentiality failure and may be exploited for IEX of sensitive data. [1] CVE Description &quotSamsung KNOX 1.0 uses a weak eCryptFS Key generation algorithm, which makes it easier for local users to obtain sensitive information by leveraging knowledge of the TIMA key and a brute-force attack.&quot [2] Analysis The following analysis is based on information in [3]: The TIMA key is a random stored byte string. The secret key used is obtained by XOR of the TIMA key and the password characters, where the minimum password length is 7. However, if the password length is no more than 8, a base 64 expansion results in a key that does not depend on the password. The TIMA key is stored, and for a known TIMA key, the key is known, or, if the password length slightly exceeds 8, there is a small set of possible keys. The TIMA key can be obtained using a preliminary step. Source Code Code With Bug	Code With Fix CVE-2015-0204, 1637, 1067 (FREAK - Factoring attack on RSA-Export Keys) BF Taxonomy An inner KMN leads to an inner ENC, which leads to an outer ENC. Inner KMN: Cause: Improper Offer of Weak Protocol (Export RSA – offered from MITM-tricked server and accepted by client) Attributes: Cryptographic Data: Keying Material (pair of private and public keys) Data State: Transferred (over network) Algorithm: Export RSA (512-bits key generation based on prime numbers, such that private key can be obtained from public key through factorization) Operation: Generate Consequence: IEX Keying Material (private key) Inner ENC: Causes: KMN Fault leads to Exposed Private Key Attributes: Sensitive Data: Cryptographic (Pre-Master Secret) Data State: Transferred (over network) Algorithm: Asymmetric (RSA) (that allows decryption of Pre-Master Secret using exposed private key and computation of Master Secret) Security Service: Confidentiality Consequence: IEX of Sensitive Data (Master Secret) Outer ENC: Causes: KMN Fault leads to Exposed Secret Key (Master Secret) Attributes: Sensitive Data: Credentials (passwords, credit cards) Data State: Transferred (over network) Algorithm: Symmetric (key is known) Security Service: Confidentiality Consequence: IEX of Sensitive Data (credentials) BF Description An inner KMN leads to an inner ENC, which leads to an outer ENC. Inner KMN: Improper offer of weak protocol (Export RSA from MITM-tricked server and accepted by client) allows use of 512-bits key generation (based on prime numbers) such that the private key can be obtained from the public key through factorization, which may be exploited for IEX of keying material (private key). Inner ENC: KMN fault leads to exposed private key for asymmetric encryption (RSA) that allows decryption of transferred (over network) cryptographic data (Pre-Master Secret) and computation of other cryptographic data (Master Secret), which is confidentiality failure and IEX of sensitive data (Master Secret). Outer ENC: KMN fault leads to exposed secret key (Master Secret) for symmetric encryption allows decryption of credentials (passwords, credit cards, etc.) transferred (over network), which is confidentiality failure and IEX of sensitive data (passwords, credit cards, etc.). [1] CVE Descriptions &quotThe ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct RSA-to-EXPORT_RSA downgrade attacks and facilitate brute-force decryption by offering a weak ephemeral RSA key in a noncompliant role, related to the &quotFREAK&quot issue. NOTE: the scope of this CVE is only client code based on OpenSSL, not EXPORT_RSA issues associated with servers or other TLS implementations.&quot [4] &quotSchannel (aka Secure Channel) in Microsoft Windows Server 2003 SP2, Windows Vista SP2, Windows Server 2008 SP2 and R2 SP1, Windows 7 SP1, Windows 8, Windows 8.1, Windows Server 2012 Gold and R2, and Windows RT Gold and 8.1 does not properly restrict TLS state transitions, which makes it easier for remote attackers to conduct cipher-downgrade attacks to EXPORT_RSA ciphers via crafted TLS traffic, related to the &quotFREAK&quot issue, a different vulnerability than CVE-2015-0204 and CVE-2015-1067.&quot [5] &quotSecure Transport in Apple iOS before 8.2, Apple OS X through 10.10.2, and Apple TV before 7.1 does not properly restrict TLS state transitions, which makes it easier for remote attackers to conduct cipher-downgrade attacks to EXPORT_RSA ciphers via crafted TLS traffic, related to the &quotFREAK&quot issue, a different vulnerability than CVE-2015-0204 and CVE-2015-1637.&quot [6] Analysis The following analysis is based on information in [7, 8, 9, 10]: The server offers a weak protocol (Export RSA) while the client requested strong protocol (RSA). Communication is encrypted by symmetric encryption. The key for that encryption (Master Secret) is created by both client and server from a Pre-Master Secret and nonces sent by client and server. The Pre-Master Secret is sent encrypted by RSA cryptosystem. The client requests RSA protocol, but man in the middle (MITM) intercepts and requests Export RSA that uses a 512 bit key. Factoring a 512 bit RSA key is feasible. Because of a bug, the client agrees to Export RSA. MITM factors the public 512 bit public RSA key, uses this factoring to recover the private RSA key, and then uses that private key to decrypt the Pre-Master Secret. Then it uses the Pre-Master Secret and the nonces to generate the Master Secret. The Master Secret enables MITM to decrypt the encrypted communication from that point on. Source Code FREAK Client Code With Bug FREAK Client Code With Fix FREAK Server Code With Bug FREAK Server Code With Fix References  [1] Bojanova, I., Black, P. E., Yesha, Y., Wu, Yan, Evans, Z., Poster: The Bugs Framework (BF) – First Classes: Buffer Overflow (BOF), Injection (INJ), Control of Interaction Frequency (CIF), STC 2017, NIST, Gaithersburg, MD, USA. [2] The MITRE Corporation, CVE-2016-1919. [3] openwall.net, [CVE-2016-1919] &quotWeak eCryptFS Key generation from user password.&quot [4] The MITRE Corporation, CVE-2015-0204. [5] The MITRE Corporation, CVE-2015-1637. [6] The MITRE Corporation, CVE-2015-1067. [7] R. Heaton, &quotThe SSL FREAK vulnerability explained.&quot [8] Censys, The FREAK Attack. [9] StackExchange, Protecting phone from the FREAK bug. [10] GitHub, openssl, Only allow ephemeral RSA keys in export ciphersuites.", "tags": "KMN", "url": "https://samate.nist.gov/BF/Examples/KMN.html"},

     {"title": "Examples - Faulty Result", "text": "CVE-2011-4093 BF Taxonomy Cause: Programmer Error - no account for overflow/maximum int and reuse of ID Also: A proper CIF (preventing an attacker from making UINT_MAX - about 4 billion - connections) may have reduced the chance of exploiting the vulnerability. Attributes: Result Fault: overflow Operation: ++ (pre-increment) Operand Error: value too big -> wrap-around Type(s): unsigned int Magnitude: small Excursion: continuous Consequence: IEX (attacker is logged in as someone else) BF Description Programmer did not account for overflow or maximum int, allowing overflow from pre-increment (++) to become too big, wrap around, and reuse an ID already assigned to another user. Faulty CIF allowed attacker to make billions of connection to cause the overflow. CVE Description Integer overflow in inc/server.hpp in libnet6 (aka net6) before 1.3.14 might allow remote attackers to hijack connections and gain privileges as other users by making billions of connections until the overflow occurs and an ID of another user is provided. Analysis Fix summary: Change algorithm to use the lowest available user ID. That is, reuse (unused) low IDs instead of always using the next higher ID. Source Code Host Code With Bug Host Code With Fix Server Code With Bug Server Code With Fix CVE-2012-5143 BF Taxonomy Cause: Programmer error - no account for overflow. Attributes: Result Fault: overflow Operation: * (multpily) Operand Error: value too big Type(s): int64 Magnitude: Moderate Excursion: Discrete Consequence: (The next significant code action was to call init. Guess is that this caused a BOF. Did not follow code to see what happened.) DoS or other. BF Description Programmer did not account for overflow. Invalid parameters eventually lead to DoS. CVE Description Integer overflow in Google Chrome before 23.0.1271.97 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to PPAPI image buffers. Analysis Fix summary: Rearrange computation to avoid possibility of overflow. Specifically, compute x >= y/4 instead of x*4 >= y. Source Code Code With Bug Code With Fix CVE-2016-5221 BF Taxonomy Cause: Programmer error - no account for overflow. Attributes: Result Fault: overflow Operation: + Operand Error: overflow - value too big Type(s): int Magnitude: Large Excursion: Discrete Consequence: incorrect calculation (buffer was calculated to be large enough, when it wasn't) -> Data Too Big -> BOF Note: There are two checks here, one for the read buffer and one for the write buffer. Both have the same FRS. So one FRS could lead to BOF/read and the other to BOF/write. BF Description Programmer did not account for overflow, allowing overflow from + to become too big, wrap around, and incorrectly calculate that the buffer was big enough, which leads to data too big, which leads to BOF/Read or BOF/Write. CVE Description Type confusion in libGLESv2 in ANGLE in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android possibly allowed a remote attacker to bypass buffer validation via a crafted HTML page. Analysis Referenced from https://bugs.chromium.org/p/chromium/issues/detail?id=660854 Fix summary: check the result computed for value too big Fix detail: Use a safe math package (CheckedNumeric) to check for overflow. While making this fix, programmer added other checks, too. Four lines of checking code became fourteen (or more!) lines. Source Code Code With Bug Code With Fix", "tags": "FRS FRS FRS FRS FRS FRS FRS FRS FRS FRS FRS ", "url": "https://samate.nist.gov/BF/Examples/FRS.html"},

     {"title": "Definitions", "text": "Software Weakness  &quotA piece of code that may lead to a vulnerability.&quot [1] Security Vulnerability &quotA property of system requirements, design, implementation, or operation that could be accidentally triggered or intentionally exploited and result in a security failure.&quot [1] Software Attack &quotThe use of an exploit(s) by an adversary to take advantage of a weakness(s) with the intent of achieving a negative technical impact(s). An attack includes the entire &quotCyber Attack Lifecycle&quot reconnaissance, weaponize, deliver, exploit, control, execute, and maintain.&quot [2] Security Failure &quotAny event that is a violation of a particular system's explicit or implicit security policy.&quot [1] &quotthe source of any failure is a latent vulnerability.&quot [1] &quotif there is a failure, there must have been a vulnerability.&quot [1] Source Code &quotA series of statements written in a human-readable computer programming language.&quot [1] A vulnerability is the result [of the exploitation] of one or more weaknesses in requirements, design, implementation, or operation. Sometimes a weakness can never result in a failure, in which case it is not exploitable and not a vulnerability. Such a weakness might be masked by another part of the software or might only cause a failure in combination with another weakness. Thus we use the term &quotweakness&quot instead of &quotflaw&quot or &quotdefect.&quot [1] References [1] Black, P., Kass, M., Koo. M., Fong, E. Source Code Security Analysis Tool Functional Specification Version 1.1, NIST Special Publication 500-268 v1.1. [2] The MITRE Corporation. Common Attack Pattern Enumeration and Classification (CAPEC), Glosary, Attack.", "tags": "Definitions", "url": "https://samate.nist.gov/BF/Enlightenment/Definitions.html"},

     {"title": "Other Classifications", "text": "Common Weakness Enumeration (CWE)  Common Weakness Enumeration (CWE) is an encyclopedia of over 600 types of software weaknesses . Some of the classes are buffer overflow, directory traversal, OS injection, race condition, cross-site scripting, hard-coded password and insecure random numbers. CWE is a widely-used compilation, which has gone through many iterations. Many tools and projects are based on it. Each CWE has a variety of information,bsuch as description summary, extended description, white box definition, consequences, examples, background details and other notes, recorded occurrences (Common Vulnerabilities and Exposures or CVE), mitigations, relations to other CWEs, and references. Software Fault Patterns (SFP) Software Fault Patterns (SFP)  are a clustering of CWEs into related weakness categories. Each cluster is factored into formally defined attributes, with sites footholds, conditions, properties, sources, sinks, etc. This work overcomes the problem of combinations of attributes in CWE. For instance, the SFP factored attributes are more clear than the irregular coverage of CWEs. Semantic Templates (ST) Semantic templates (ST) build mental models, which help us understand software weaknesses. Each ST is a human and machine understandable representation of: The software faults that lead to a weakness. The resources that a weakness affects. The weakness attributes. The consequences/failures resulting from the weakness.&quot  The NSA Center for Assured Software (CAS) The NSA Center for Assured Software (CAS) defines the following Weakness Classes in its &quotStatic Analysis Tool Study - Methodology&quot Software State-of-the-Art Resources (SOAR) The Software State-of-the-Art Resources (SOAR) Matrix defines and describes a process for selecting and using appropriate analysis tools and techniques for evaluating software for software (security) assurance. In particular, it identifies types of tools and techniques available for evaluating software, as well as the following technical objectives those tools and techniques can meet : SEI CERT C Coding Standard The SEI CERT C Coding Standard defines the following &quotrules for secure coding in the C programming language&quot with the goal to &quotto develop safe, reliable, and secure systems, for example by eliminating undefined behaviors that can lead to undefined program behaviors and exploitable vulnerabilities&quot Common Vulnerabilities and Exposures (CVE) The Common Vulnerabilities and Exposures (CVE) is &quota dictionary of publicly known information security vulnerabilities and exposures&quot . &quotCVE’s common identifiers enable data exchange between security products and provide a baseline index point for evaluating coverage of tools and services.&quot. Open Web Application Security Project (OWASP) The Software Fault Patterns (SFP)  are a clustering of CWEs into related weakness categories. Each cluster is factored into formally defined attributes, with sites footholds, conditions, properties, sources, sinks, etc. This work overcomes the problem of combinations of attributes in CWE. For instance, the SFP factored attributes are more clear than the irregular coverage of CWEs. Common Attack Pattern Enumeration and Classification (CAPEC) The Common Attack Pattern Enumeration and Classification (CAPEC) &quotis a comprehensive dictionary and classification taxonomy of known attacks that can be used by analysts, developers, testers, and educators to advance community understanding and enhance defenses&quot ISO/IEC JTC1/SC22/WG23 Technical Report ISO/IEC/JTC 1/SC 22/WG 23 is working on a Technical Report (RT), which includes a &quottaxonomic hierarchy of vulnerabilities&quot, giving each vulnerability an arbitrary three-letter code . The general part, TR 24772-1, is an and applies to all languages. There are many supplements, one for each language -- for example, TR24772-2 Ada, TR24772-3 C, and TR24772-9 C++. SW91 Classification of Defects in Health Software&quot, Association for the Advancement of Medical Instrumentation (AAMI) Committee Draft Version", "tags": "", "url": "https://samate.nist.gov/BF/Enlightenment/otherclassifications.html"},

     {"title": "Common Weakness Enumeration", "text": "The Common Weakness Enumeration (CWE) is an &quotencyclopedia&quot of over 600 types of software weaknesses [1]. Some of the classes are buffer overflow, directory traversal, OS injection, race condition, cross-site scripting, hard-coded password and insecure random numbers. CWE is a widely-used compilation, which has gone through many iterations. Many tools and projects are based on it. Each CWE has a variety of information, such as description summary, extended description, white box definition, consequences, examples, background details and other notes, recorded occurrences (Common Vulnerabilities and Exposures or CVE), mitigations, relations to other CWEs, and references.  Examples CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') &quotThe software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.&quot [2] CWE-226: Sensitive Information Uncleared Before Release &quotThe software does not fully clear previously used information in a data structure, file, or other resource, before making that resource available to a party in another control sphere.&quot [3] Notes CWEs are a rich source of material for software developers and superior to anything that existed before. However, for very formal, exacting work, CWE definitions are often inaccurate, imprecise or ambiguous, and the various definitions within one CWE can be inconsistent. Each CWE bundles many stages, such as likely attacks, resources affected and consequences. The coverage is uneven, with some combinations of attributes well represented and others not appearing at all. An extreme example is path traversal. There are a dozen CWEs for path traversal under CWE-23: Relative Path Traversal, each one having a specific combination of relative or absolute paths, forward or backward slashes - singly or repeated, between one and three directory steps, and two or more dots, which indicate the parent directory. Another example is buffer overflows. CWE-121 is write outside of a buffer on the stack, CWE-122 is write outside of a buffer in the heap, CWE-127 is read before the beginning of a buffer and CWE-126 is read after the end of a buffer. But there are no CWEs specifically for read outside a buffer on the stack vs. in the heap. The description summary of CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer is &quotThe software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer.&quot Note that &quotread from or write to a memory location&quot is not explicitly tied to the buffer! Most humans would, of course, assume that it means the software can access through a buffer a memory location that is not allocated to that buffer. References [1] The MITRE Corporation. Common Weakness Enumeration (CWE). [2] The MITRE Corporation. CWE Common Weakness Enumeration. CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'). [3] The MITRE Corporation. CWE Common Weakness Enumeration. CWE-226: Sensitive Information Uncleared Before Release.", "tags": "CWE", "url": "https://samate.nist.gov/BF/Enlightenment/CWE.html"},

     {"title": "Software Fault Patterns", "text": "The Software Fault Patterns (SFP) [1] are a clustering of CWEs into related weakness categories. Each cluster is factored into formally defined attributes, with sites (&quotfootholds&quot), conditions, properties, sources, sinks, etc. This work overcomes the problem of combinations of attributes in CWE. For instance, the SFP factored attributes are more clear than the irregular coverage of CWEs.  &quotSoftware Fault Patterns (SFP) is a generalized description of an identifiable family of computations that are: Described as patterns with an invariant core and variant parts. Aligned with injury. Aligned with operational views and risk through events. Fully identifiable in code (discernable). Aligned with CWE. With formally defined characteristics.&quot [2] SFP categorizes 632 CWEs plus there are 8 deprecated CWEs, so the CWEs defined as weaknesses total 640. In addition, there are: 21 primary clusters, 62 secondary clusters, 310 discernible CWEs, 36 unique SFPs. [3] Example SFP 8 Faulty Buffer Access &quotPrimary Cluster: Memory Access; Secondary Cluster: Faulty Buffer Access A weakness where the code path has all of the following: an end statement that performs a Buffer Access Operation and where exactly one of the following is true: the access position of the Buffer Access Operation is outside of the buffer or the access position of the Buffer access Operation is inside the buffer and the size of the data being accessed is greater than the remaining size of the buffer at the access position. This is where the Buffer Access Operation is a statement that performs access to a data item of a certain size at access position. The access position of a Buffer access Operation is related to a certain buffer and can be either inside the buffer or outside of the buffer. Parameters: Access: Reads, Writes Buffer: Stack, Heap Access Position: Array with index, Pointer.&quot [3] Notes SFP is an excellent advance. However, SFP does not tie fault clusters to causes or chains of fault patterns nor to consequences of a particular vulnerability. In addition, since they were derived from CWEs, more work is needed for embedded or mobile concerns, such as, battery drain, physical sensors (e.g. Global Positioning System (GPS) location, gyroscope, microphone, camera) and wireless communications. References [1] N. Mansourov and D. Campara, &quotSystem Assurance: Beyond Detecting Vulnerabilities.&quot Morgan Kaufmann. 2010. pp. 176-188. [2] N. Mansourov. DoD Software Fault Patterns. KDM Analytics, Inc. 2011. [3] B. A. Calloni, D. Campara, and N. Mansourov. White Box Definitions of Software Fault Patterns. Final Report. Lockheed Martin Corporation and KDM Analytics, Inc. 2011.", "tags": "SFP", "url": "https://samate.nist.gov/BF/Enlightenment/SFP.html"},

     {"title": "Semantic Templates", "text": "The Semantic templates (ST) build mental models, which help us understand software weaknesses. Each ST is a human and machine understandable representation of: The software faults that lead to a weakness. The resources that a weakness affects. The weakness attributes. The consequences/failures resulting from the weakness.&quot [1] Semantic Templates factor out chains of causes, resources and consequences that are present in CWEs. For example, see below the phrases in the description summary, extended description and common consequences of CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow'), labeled according to the phases called out by Semantic Templates. Details on the Injection, Buffer Overflow, and Information Leak semantic templates are presented in [2]. References [1] Wu, Y., Gandhi, R. A., Siy, H. Using Semantic Templates to Study Vulnerabilities Recorded in Large Software Repositories. Proc. 2010 ICSE Workshop on Software Engineering for Secure Systems. SESS '10. New York, NY: ACM. 2010. pp. 22-28. [2] Gandh, R. Studying Software Vulnerabilities.", "tags": "ST", "url": "https://samate.nist.gov/BF/Enlightenment/ST.html"},

     {"title": "NSA Center for Assured Software", "text": "The NSA Center for Assured Software (CAS) defines the following Weakness Classes in its &quotStatic Analysis Tool Study - Methodology&quot [1]:  Weakness Class Example Weakness (CWE Entry [2]) Authentication and Access Control	CWE-620: Unverified Password Change Buffer Handling	 CWE-121: Stack-based Buffer Overflow Code Quality CWE-561: Dead Code Control Flow Management CWE-362: Race Condition Encryption and Randomness	CWE-328: Reversible One-Way Hash Error Handling	CWE-252: Unchecked Return Value File Handling CWE-23: Relative Path Traversal Information Leaks CWE-534: Information Leak Through Debug Log Files Initialization and Shutdown CWE-415: Double Free Injection CWE-89: SQL Injection Malicious Logic CWE-506: Embedded Malicious Code Miscellaneous	CWE-480: Use of Incorrect Operator Number Handling	CWE-369: Divide by Zero Pointer and Reference Handling	CWE-476: Null Pointer Dereference References [1] Center for Assured Software (CAS), National Security Agency (NSA). CAS Static Analysis Tool Study - Methodology. 2011. [2] The MITRE Corporation. Common Weakness Enumeration (CWE).", "tags": "NSA", "url": "https://samate.nist.gov/BF/Enlightenment/CAS.html"},

     {"title": "Software State-Of-The-Art Resources Matrix", "text": "The Software State-of-the-Art Resources (SOAR) Matrix defines and describes a process for selecting and using appropriate analysis tools and techniques for evaluating software for software (security) assurance. In particular, it identifies types of tools and techniques available for evaluating software, as well as the following technical objectives those tools and techniques can meet [1]: References [1] Larsen, G., Kenneth Hong Fong, E., Wheeler, D. A., Moorthy. R. S. State-of-the-Art Resources (SOAR) for Software Vulnerability Detection, Test, and Evaluation. 2014. [2] Institute for Defense Analyses (IDA). Software State-of-the-Art Resources (SOAR) Matrix.", "tags": "SOAR", "url": "https://samate.nist.gov/BF/Enlightenment/SOAR.html"},

     {"title": "CERT C Coding Standard", "text": "The SEI CERT C Coding Standard defines the following &quotrules for secure coding in the C programming language&quot with the goal to &quotto develop safe, reliable, and secure systems, for example by eliminating undefined behaviors that can lead to undefined program behaviors and exploitable vulnerabilities&quot [1].  Preprocessor (PRE) PRE30-C. Do not create a universal character name through concatenation PRE31-C. Avoid side effects in arguments to unsafe macros PRE32-C. Do not use preprocessor directives in invocations of function-like macros Declarations and Initialization (DCL) DCL30-C. Declare objects with appropriate storage durations DCL31-C. Declare identifiers before using them DCL36-C. Do not declare an identifier with conflicting linkage classifications DCL37-C. Do not declare or define a reserved identifier DCL38-C. Use the correct syntax when declaring a flexible array member DCL39-C. Avoid information leakage when passing a structure across a trust boundary DCL40-C. Do not create incompatible declarations of the same function or object DCL41-C. Do not declare variables inside a switch statement before the first case label Expressions (EXP) EXP30-C. Do not depend on the order of evaluation for side effects EXP32-C. Do not access a volatile object through a nonvolatile reference EXP33-C. Do not read uninitialized memory EXP34-C. Do not dereference null pointers EXP35-C. Do not modify objects with temporary lifetime EXP36-C. Do not cast pointers into more strictly aligned pointer types EXP37-C. Call functions with the correct number and type of arguments EXP39-C. Do not access a variable through a pointer of an incompatible type EXP40-C. Do not modify constant objects EXP42-C. Do not compare padding data EXP43-C. Avoid undefined behavior when using restrict-qualified pointers EXP44-C. Do not rely on side effects in operands to sizeof, _Alignof, or _Generic EXP45-C. Do not perform assignments in selection statements EXP46-C. Do not use a bitwise operator with a Boolean-like operand Integers ( INT) INT30-C. Ensure that unsigned integer operations do not wrap INT31-C. Ensure that integer conversions do not result in lost or misinterpreted data INT32-C. Ensure that operations on signed integers do not result in overflow INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand INT35-C. Use correct integer precisions INT36-C. Converting a pointer to integer or integer to pointer Floating Point ( FLP) FLP30-C. Do not use floating-point variables as loop counters FLP32-C. Prevent or detect domain and range errors in math functions FLP34-C. Ensure that floating-point conversions are within range of the new type FLP36-C. Preserve precision when converting integral values to floating-point type FLP37-C. Do not use object representations to compare floating-point values Array ( ARR) ARR30-C. Do not form or use out-of-bounds pointers or array subscripts ARR32-C. Ensure size arguments for variable length arrays are in a valid range ARR36-C. Do not subtract or compare two pointers that do not refer to the same array ARR37-C. Do not add or subtract an integer to a pointer to a non-array object ARR38-C. Guarantee that library functions do not form invalid pointers ARR39-C. Do not add or subtract a scaled integer to a pointer Characters and Strings ( STR) STR30-C. Do not attempt to modify string literals STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator STR32-C. Do not pass a non-null-terminated character sequence to a library function that expects a string STR34-C. Cast characters to unsigned char before converting to larger integer sizes STR37-C. Arguments to character-handling functions must be representable as an unsigned char STR38-C. Do not confuse narrow and wide character strings and functions Memory Management ( MEM) MEM30-C. Do not access freed memory MEM31-C. Free dynamically allocated memory when no longer needed MEM33-C. Allocate and copy structures containing a flexible array member dynamically MEM34-C. Only free memory allocated dynamically MEM35-C. Allocate sufficient memory for an object MEM36-C. Do not modify the alignment of objects by calling realloc() Input/Output ( FIO) FIO30-C. Exclude user input from format strings FIO32-C. Do not perform operations on devices that are only appropriate for files FIO34-C. Distinguish between characters read from a file and EOF or WEOF FIO37-C. Do not assume that fgets() or fgetws() returns a nonempty string when successful FIO38-C. Do not copy a FILE object FIO39-C. Do not alternately input and output from a stream without an intervening flush or positioning call FIO40-C. Reset strings on fgets() or fgetws() failure FIO41-C. Do not call getc(), putc(), getwc(), or putwc() with a stream argument that has side effects FIO42-C. Close files when they are no longer needed FIO44-C. Only use values for fsetpos() that are returned from fgetpos() FIO45-C. Avoid TOCTOU race conditions while accessing files FIO46-C. Do not access a closed file FIO47-C. Use valid format strings Environment ( ENV) ENV30-C. Do not modify the object referenced by the return value of certain functions ENV31-C. Do not rely on an environment pointer following an operation that may invalidate it ENV32-C. All exit handlers must return normally ENV33-C. Do not call system() ENV34-C. Do not store pointers returned by certain functions Signals ( SIG) SIG30-C. Call only asynchronous-safe functions within signal handlers SIG31-C. Do not access shared objects in signal handlers SIG34-C. Do not call signal() from within interruptible signal handlers SIG35-C. Do not return from a computational exception signal handler Error Handling ( ERR) ERR30-C. Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure ERR32-C. Do not rely on indeterminate values of errno ERR33-C. Detect and handle standard library errors Concurrency ( CON) CON30-C. Clean up thread-specific storage CON31-C. Do not destroy a mutex while it is locked CON32-C. Prevent data races when accessing bit-fields from multiple threads CON33-C. Avoid race conditions when using library functions CON34-C. Declare objects shared between threads with appropriate storage durations CON35-C. Avoid deadlock by locking in a predefined order CON36-C. Wrap functions that can spuriously wake up in a loop CON37-C. Do not call signal() in a multithreaded program CON38-C. Preserve thread safety and liveness when using condition variables CON39-C. Do not join or detach a thread that was previously joined or detached CON40-C. Do not refer to an atomic variable twice in an expression CON41-C. Wrap functions that can fail spuriously in a loop Miscellaneous ( MSC) MSC30-C. Do not use the rand() function for generating pseudorandom numbers MSC32-C. Properly seed pseudorandom number generators MSC33-C. Do not pass invalid data to the asctime() function MSC37-C. Ensure that control never reaches the end of a non-void function MSC38-C. Do not treat a predefined identifier as an object if it might only be implemented as a macro MSC39-C. Do not call va_arg() on a va_ list that has an indeterminate value MSC40-C. Do not violate constraints References [1] SEI CERT. C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems. 2016.", "tags": "CERT SEI-CERT", "url": "https://samate.nist.gov/BF/Enlightenment/CERT%20C.html"},

     {"title": "Common Vulnerablities and Exposures", "text": "The Common Vulnerabilities and Exposures (CVE) is &quota dictionary of publicly known information security vulnerabilities and exposures&quot [1]. &quotCVE's common identifiers enable data exchange between security products and provide a baseline index point for evaluating coverage of tools and services.&quot[1].  Examples CVE-2014-0160 (Heartbleed) &quotThe (1) TLS and (2) DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug.&quot [2] CVE 2007-3572 (Yoggie Pico) &quotIncomplete blacklist vulnerability in cgi-bin/runDiagnostics.cgi in the web interface on the Yoggie Pico and Pico Pro allows remote attackers to execute arbitrary commands via shell metacharacters in the param parameter, as demonstrated by URL encoded &quot`&quot (backtick) characters (%60 sequences).&quot [3] References [1] The MITRE Corporation. Common Vulnerabilities and Exposures or (CVE). [2] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2014-0160. [3] The MITRE Corporation, CVE Common Vulnerabilities and Exposures, CVE-2007-3572.", "tags": "CVE", "url": "https://samate.nist.gov/BF/Enlightenment/CVE.html"},

     {"title": "Open Web Application Security Project", "text": "The Open Web Application Security Project (OWASP) defines the following categories of vulnerabilities [1]:  API Abuse Authentication Vulnerability Authorization Vulnerability Availability Vulnerability Code Permission Vulnerability Code Quality Vulnerability Configuration Vulnerability Cryptographic Vulnerability Encoding Vulnerability Environmental Vulnerability Error Handling Vulnerability General Logic Error Vulnerability Input Validation Vulnerability Logging and Auditing Vulnerability Password Management Vulnerability Path Vulnerability Sensitive Data Protection Vulnerability Session Management Vulnerability Unsafe Mobile Code Use of Dangerous API References [1] Open Web Application Security Project (OWASP), 2016.", "tags": "OWASP", "url": "https://samate.nist.gov/BF/Enlightenment/OWASP.html"},

     {"title": "Common Attack Pattern Enumeration and Classification", "text": "The Common Attack Pattern Enumeration and Classification (CAPEC) &quotis a comprehensive dictionary and classification taxonomy of known attacks that can be used by analysts, developers, testers, and educators to advance community understanding and enhance defenses&quot [1]. Examples CAPEC-66: SQL Injection &quotThis attack exploits target software that constructs SQL statements based on user input. An attacker crafts input strings so that when the target software constructs SQL statements based on the input, the resulting SQL statement performs actions other than those the application intended...&quot [2] CAPEC-540: Overread Buffers &quotAn adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.&quot [3] References [1] The MITRE Corporation. Common Attack Pattern Enumeration and Classification (CAPEC). [2] The MITRE Corporation. CAPEC Common Attack Pattern Enumeration and Classification. CAPEC-66: SQL Injection. [3] The MITRE Corporation. CAPEC Common Attack Pattern Enumeration and Classification. CAPEC-540: Overread Buffers.", "tags": "CAPEC", "url": "https://samate.nist.gov/BF/Enlightenment/CAPEC.html"},

     {"title": "ISO/IEC JTC1/SC22/WG23 Technical Report", "text": "ISO/IEC/JTC 1/SC 22/WG 23 is working on a Technical Report (RT), which includes a &quottaxonomic hierarchy of vulnerabilities&quot, giving each vulnerability an arbitrary three-letter code [1]. The general part, TR 24772-1, is an and applies to all languages. There are many supplements, one for each language -- for example, TR24772-2 Ada, TR24772-3 C, and TR24772-9 C++. The heart of the TR is specific suggestions to avoid vulnerabilities that arise from &quotconstructs that incompletely specified, exhibit undefined behavior, are implementation-dependent, or are difficult to use correctly.&quot The classes of vulnerabilities can also be used to &quotselect source code evaluation tools that can discover and eliminate some constructs that could lead to vulnerabilities&quot. Some suggestions are, &quotAssume all input is malicious&quot, &quotUse appropriate combinations of black-lists and white-lists ...&quot, &quotUse sanitizers to scrub input ...&quot, &quotCompare multiple attributes of the file to improve the likelihood that the file is the expected one&quot, and &quotRestrict the use of shared directories&quot. A.2 Outline of Programming Language Vulnerabilities A.2.1. Types  A.2.1.1. Representation A.2.1.1.1. [IHN] Type System A.2.1.1.2. [STR] Bit Representations A.2.1.2. Floating-point A.2.1.2.1. [PLF] Floating-point Arithmetic A.2.1.3. Enumerated Types A.2.1.3.1. [CCB] Enumerator Issues A.2.1.4. Integers A.2.1.4.1. [FLC] Numeric Conversion Errors A.2.3. Declarations and Definitions A.2.3.1. [NAI] Choice of Clear Names A.2.3.2. [WXQ] Dead store A.2.3.3. [YZS] Unused Variable A.2.5. Control Flow A.2.5.1. Conditional Statements A.2.5.1.1. [CLL] Switch Statements and Static Analysis A.2.5.1.2. [EOJ] Demarcation of Control Flow A.2.5.2. Loops A.2.5.2.1. [TEX] Loop Control Variables A.2.5.2.2. [XZH] Off-by-one Error A.2.9. Macros A.2.9.1. [NMP] Pre-processor Directives A.2.10. Compile/Run Time A.2.10.1 [MXB] Suppression of Language-Defined Run-Time Checking A.2.10.2 [SKL] Provision of Inherently Unsafe Operations A.2.11. Language Specification Issues A.2.11.1. [BRS] Obscure Language Features A.2.11.2. [BQF] Unspecified Behaviour A.3 Outline of Application Vulnerabilities A.3.1. Design Issues A.3.1.1. [BVQ] Unspecified Functionality A.3.1.2 [REU] Fault Tolerance and Failure Strategies A.3.1.3. [KLK] Distinguished Values in Data Types A.3.2. Environment A.3.2.1. [XYN] Adherence to Least Privilege A.3.2.2. [XYO] Privilege Sandbox Issues A.3.2.3. [XYS] Executing or Loading Untrusted Code A.3.3. Resource Management A.3.3.1. Memory Management A.3.3.1.1. [XZX] Memory Locking A.3.4 Concurrency and Parallelism A.3.4.1 [CGY] Inadequately Secure Communication of Shared Resources A.3.5. Flaws in Security Functions A.3.5.1. [XZS] Missing Required Cryptographic Step A.3.5.2. [MVX] Use of a One-Way Hash without a Salt A.3.5.2. Authentication A.3.5.2.1. [XZR] Improperly Verified Signature A.3.5.2.2. [XYM] Insufficiently Protected Credentials", "tags": "ISO/IEC JTC1/SC22/WG23 Technical Report References [1] ISO/IEC/JTC 1/SC 22/WG 23 DOCUMENT REGISTER.", "url": "https://samate.nist.gov/BF/Enlightenment/ISOIECJTCTR.html"},

     {"title": "SW91", "text": "&quotClassification of Defects in Health Software&quot, Association for the Advancement of Medical Instrumentation (AAMI) Committee Draft Version (CDV) 2, SW91, 2017-04-21", "tags": "SW91", "url": "https://samate.nist.gov/BF/Enlightenment/SW91.html"},

     {"title": "Publications", "text": "Bojanova, I., Black, P. E., Yesha, Y., Cryptography Classes in Bugs Framework (BF): Encryption Bugs (ENC), Verification Bugs (VRF), and Key Management Bugs (KMN). I&quotware Technology Conference (STC 2017), NIST, Gaithersburg, USA. September 25-28, 2017. Black, P. E., Bojanova, I., Defeating Buffer Overflow: A Trivial but Dangerous Bug . IT Professional (Securing IT). Nov-Dec, 2016. Bojanova, I., Black, P. E., Yesha, Y., Wu, Y., The Bugs Framework (BF): A Structured Approach to Express Bugs. 2016 IEEE International Conference on Software Quality, Reliability, and Security (QRS 2016), Vienna, Austria. August 1-3, 2016. Wu, Y., Bojanova, I., Yesha, Y., They Know Your Weaknesses - Do You?: Reintroducing Common Weakness Enumeration. CrossTalk (The Journal of Defense Software Engineering). Sept-Oct, 2015.", "tags": "Publications", "url": "https://samate.nist.gov/BF/Publications/index.html"},

     {"title": "BF Team", "text": "Irena Bojanova (Project Lead) is a computer scientist at NIST. Previously she was a program chair at UMUC, an academic director at JHU-CTY, and a co-founder of OBS &quot(now CSC Bulgaria). She earned her Ph.D. in Mathematics/ Computer Science from the Bulgarian Academy of Sciences in 1991. Irena serves EIC of IEEE IT Professional magazine, co-chair of IEEE RS IoT TC and founding member of IEEE TSC on Big Data. She was the founding chair of IEEE CS Cloud Computing STC, EIC of IEEE Transactions on Cloud Computing, Committee on Integrity Chair and a Member at Large of IEEE CS Publications Board. Paul E. Black has nearly 20 years of industrial experience in developing software for IC design and verification, assuring software quality, and managing business data processing. He is the founder and editor of the Dictionary of Algorithms and Data Structures https://www.nist.gov/dads/. Black earned a Ph.D. from Brigham Young University in 1998. He taught classes at Brigham Young University and Johns Hopkins University. He has published in static analysis, software testing, networks and queuing analysis, formal methods, software verification, quantum computing, and computer forensics. He is a member of ACM and a senior member of IEEE. Yaacov Yesha is a professor at the Department of Computer Science and Electrical Engineering at the University of Maryland, Baltimore County. He earned his PhD in Computer Science in 1979 from the Weizmann Institute of Science. His research interests include software assurance and cloud computing. Yan Wu is an assistant professor at the Computer Science Department of Bowling Green State University. Previously she was a guest researcher with the SAMATE team at NIST. She earned her Ph.D. degree in Information Technology from the University of Nebraska at Omaha in 2011. Her research interests are software engineering and software assurance. Farhan Nadeem is a volunteer computer scientist at NIST. An avid technology enthusiast, he is currently exploring degree options. He is interested in programming, and is studying Java. As a new member of the SAMATE team, he is working on the website for the Bugs Framework. Zachary Evans is a former NIST volunteer, who currently works towards his Software Engineering degree at RIT.", "tags": "Team Irena Paul Yaacov Farhan", "url": "https://samate.nist.gov/BF/Team/index.html"},
]};
